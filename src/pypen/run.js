/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
	yy: {}
  }

  Parser.prototype: {
	yy: {},
	trace: function(),
	symbols_: {associative list: name ==> number},
	terminals_: {associative list: number ==> name},
	productions_: [...],
	performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
	table: [...],
	defaultActions: {...},
	parseError: function(str, hash),
	parse: function(input),

	lexer: {
		EOF: 1,
		parseError: function(str, hash),
		setInput: function(input),
		input: function(),
		unput: function(str),
		more: function(),
		less: function(n),
		pastInput: function(),
		upcomingInput: function(),
		showPosition: function(),
		test_match: function(regex_match_array, rule_index),
		next: function(),
		lex: function(),
		begin: function(condition),
		popState: function(),
		_currentRules: function(),
		topState: function(),
		pushState: function(condition),

		options: {
			ranges: boolean           (optional: true ==> token location info will include a .range[] member)
			flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
			backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
		},

		performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
		rules: [...],
		conditions: {associative list: name ==> set},
	}
  }


  token location info (@$, _$, etc.): {
	first_line: n,
	last_line: n,
	first_column: n,
	last_column: n,
	range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
	text:        (matched text)
	token:       (the produced terminal token, if any)
	line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
	loc:         (yylloc)
	expected:    (string describing the set of expected tokens)
	recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var tmp = ''
var dncl = (function () {
	var o = function (k, v, o, l) { for (o = o || {}, l = k.length; l--; o[k[l]] = v); return o }, $V0 = [4, 5, 6, 7, 8, 11, 19, 22, 31, 35, 37, 38, 39, 40, 41, 44, 46, 47, 50, 52, 53, 71, 72, 73, 74, 76, 77, 80, 113, 114, 115, 116, 117, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 143, 146], $V1 = [53, 113, 114], $V2 = [2, 61], $V3 = [1, 59], $V4 = [1, 60], $V5 = [1, 61], $V6 = [1, 62], $V7 = [1, 63], $V8 = [1, 64], $V9 = [1, 65], $Va = [1, 66], $Vb = [1, 67], $Vc = [1, 68], $Vd = [1, 69], $Ve = [1, 70], $Vf = [1, 71], $Vg = [1, 72], $Vh = [1, 22], $Vi = [1, 74], $Vj = [1, 21], $Vk = [1, 75], $Vl = [1, 78], $Vm = [1, 79], $Vn = [1, 57], $Vo = [1, 58], $Vp = [1, 55], $Vq = [1, 52], $Vr = [1, 53], $Vs = [1, 54], $Vt = [1, 77], $Vu = [1, 25], $Vv = [1, 26], $Vw = [1, 27], $Vx = [1, 28], $Vy = [1, 29], $Vz = [1, 30], $VA = [1, 31], $VB = [1, 32], $VC = [1, 33], $VD = [1, 34], $VE = [1, 35], $VF = [1, 36], $VG = [1, 37], $VH = [1, 38], $VI = [1, 39], $VJ = [1, 40], $VK = [1, 41], $VL = [1, 42], $VM = [1, 43], $VN = [1, 44], $VO = [1, 45], $VP = [1, 46], $VQ = [1, 47], $VR = [1, 48], $VS = [1, 49], $VT = [1, 50], $VU = [1, 56], $VV = [4, 5, 6, 7, 8, 11, 19, 22, 31, 35, 37, 38, 39, 40, 41, 44, 46, 47, 50, 52, 53, 71, 72, 73, 74, 75, 76, 77, 80, 84, 86, 113, 114, 115, 116, 117, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 143, 146], $VW = [2, 81], $VX = [2, 47], $VY = [2, 59], $VZ = [1, 99], $V_ = [1, 100], $V$ = [1, 101], $V01 = [1, 102], $V11 = [1, 103], $V21 = [1, 104], $V31 = [1, 105], $V41 = [1, 106], $V51 = [1, 107], $V61 = [1, 108], $V71 = [1, 109], $V81 = [1, 110], $V91 = [1, 111], $Va1 = [1, 112], $Vb1 = [1, 113], $Vc1 = [1, 114], $Vd1 = [1, 115], $Ve1 = [1, 116], $Vf1 = [1, 117], $Vg1 = [1, 118], $Vh1 = [1, 119], $Vi1 = [1, 120], $Vj1 = [1, 121], $Vk1 = [1, 122], $Vl1 = [1, 123], $Vm1 = [1, 124], $Vn1 = [1, 127], $Vo1 = [1, 159], $Vp1 = [1, 158], $Vq1 = [1, 160], $Vr1 = [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 45, 46, 48, 49, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], $Vs1 = [1, 170], $Vt1 = [1, 175], $Vu1 = [1, 176], $Vv1 = [1, 177], $Vw1 = [1, 178], $Vx1 = [45, 53], $Vy1 = [48, 53], $Vz1 = [23, 45, 48, 53, 113, 114], $VA1 = [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 44, 45, 46, 48, 49, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], $VB1 = [23, 53], $VC1 = [75, 84, 86], $VD1 = [10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 45, 46, 48, 49, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], $VE1 = [23, 33, 34, 36, 45, 46, 48, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], $VF1 = [10, 11, 16, 17, 18, 20, 21, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 45, 46, 48, 49, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], $VG1 = [16, 17, 18, 20, 21, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 45, 46, 48, 49, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], $VH1 = [23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 45, 46, 48, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], $VI1 = [2, 39], $VJ1 = [4, 5, 6, 7, 8, 11, 19, 22, 31, 35, 37, 38, 39, 40, 41, 44, 46, 47, 50, 52, 53, 71, 72, 73, 74, 75, 76, 77, 80, 84, 86, 113, 114, 115, 116, 117, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 143];
	var parser = {
		trace: function trace() { },
		yy: {},
		symbols_: { "error": 2, "e": 3, "整数値": 4, "実数値": 5, "文字列値": 6, "True": 7, "False": 8, "**": 9, "+": 10, "-": 11, "*": 12, "/": 13, "//": 14, "%": 15, "&": 16, "|": 17, "^": 18, "~": 19, "<<": 20, ">>": 21, "(": 22, ")": 23, "==": 24, "!=": 25, ">": 26, "<": 27, ">=": 28, "<=": 29, "の中に": 30, "not": 31, "in": 32, "and": 33, "or": 34, "copy": 35, "と": 36, "整数": 37, "実数": 38, "文字列": 39, "真偽": 40, "識別子": 41, "args": 42, "variable": 43, "[": 44, "]": 45, "改行": 46, "{": 47, "}": 48, "個の": 49, "UNDEFINED": 50, "slice": 51, ":": 52, "COMMA": 53, "statementlist": 54, "statement": 55, "EmptyStatement": 56, "CallStatement": 57, "AssignStatement": 58, "PrintStatement": 59, "InputStatement": 60, "GraphicStatement": 61, "ForStatement": 62, "WhileStatement": 63, "IfStatement": 64, "SleepStatement": 65, "DefineFuncStatement": 66, "ReturnStatement": 67, "DumpStatement": 68, "BreakStatement": 69, "NopStatement": 70, "何もしない": 71, "一時停止する": 72, "変数を確認する": 73, "手続き": 74, "ブロック終端": 75, "関数": 76, "手続きを抜ける": 77, "を返す": 78, "If_If": 79, "もし": 80, "ならば": 81, "If_EndIf": 82, "If_Else": 83, "そうでなければ": 84, "If_ElseIf": 85, "そうでなくもし": 86, "If_ElseIfs": 87, "を": 88, "から": 89, "まで": 90, "ずつ": 91, "増やしながら": 92, "繰り返す": 93, "減らしながら": 94, "の要素": 95, "について": 96, "の間": 97, "=": 98, "+=": 99, "-=": 100, "*=": 101, "/=": 102, "//=": 103, "%=": 104, "&=": 105, "|=": 106, "^=": 107, "<<=": 108, ">>=": 109, "に": 110, "追加する": 111, "連結する": 112, "を改行無しで表示する": 113, "を表示する": 114, "改行無しで表示する": 115, "表示する": 116, "改行する": 117, "入力する": 118, "gOpenWindow": 119, "gCloseWindow": 120, "gClearWindow": 121, "gSetLineColor": 122, "gSetFillColor": 123, "gSetTextColor": 124, "gSetLineWidth": 125, "gSetFontSize": 126, "gDrawText": 127, "gDrawLine": 128, "gDrawPoint": 129, "gDrawBox": 130, "gFillBox": 131, "gDrawCircle": 132, "gFillCircle": 133, "gDrawOval": 134, "gFillOval": 135, "gDrawArc": 136, "gFillArc": 137, "gBarplot": 138, "gLineplot": 139, "gDrawGraph": 140, "gClearGraph": 141, "ミリ秒待つ": 142, "繰り返しを抜ける": 143, "Program": 144, "SourceElements": 145, "EOF": 146, "SourceElement": 147, "$accept": 0, "$end": 1 },
		terminals_: { 2: "error", 4: "整数値", 5: "実数値", 6: "文字列値", 7: "True", 8: "False", 9: "**", 10: "+", 11: "-", 12: "*", 13: "/", 14: "//", 15: "%", 16: "&", 17: "|", 18: "^", 19: "~", 20: "<<", 21: ">>", 22: "(", 23: ")", 24: "==", 25: "!=", 26: ">", 27: "<", 28: ">=", 29: "<=", 30: "の中に", 31: "not", 32: "in", 33: "and", 34: "or", 35: "copy", 36: "と", 37: "整数", 38: "実数", 39: "文字列", 40: "真偽", 41: "識別子", 44: "[", 45: "]", 46: "改行", 47: "{", 48: "}", 49: "個の", 50: "UNDEFINED", 52: ":", 53: "COMMA", 71: "何もしない", 72: "一時停止する", 73: "変数を確認する", 74: "手続き", 75: "ブロック終端", 76: "関数", 77: "手続きを抜ける", 78: "を返す", 80: "もし", 81: "ならば", 84: "そうでなければ", 86: "そうでなくもし", 88: "を", 89: "から", 90: "まで", 91: "ずつ", 92: "増やしながら", 93: "繰り返す", 94: "減らしながら", 95: "の要素", 96: "について", 97: "の間", 98: "=", 99: "+=", 100: "-=", 101: "*=", 102: "/=", 103: "//=", 104: "%=", 105: "&=", 106: "|=", 107: "^=", 108: "<<=", 109: ">>=", 110: "に", 111: "追加する", 112: "連結する", 113: "を改行無しで表示する", 114: "を表示する", 115: "改行無しで表示する", 116: "表示する", 117: "改行する", 118: "入力する", 119: "gOpenWindow", 120: "gCloseWindow", 121: "gClearWindow", 122: "gSetLineColor", 123: "gSetFillColor", 124: "gSetTextColor", 125: "gSetLineWidth", 126: "gSetFontSize", 127: "gDrawText", 128: "gDrawLine", 129: "gDrawPoint", 130: "gDrawBox", 131: "gFillBox", 132: "gDrawCircle", 133: "gFillCircle", 134: "gDrawOval", 135: "gFillOval", 136: "gDrawArc", 137: "gFillArc", 138: "gBarplot", 139: "gLineplot", 140: "gDrawGraph", 141: "gClearGraph", 142: "ミリ秒待つ", 143: "繰り返しを抜ける", 146: "EOF" },
		productions_: [0, [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 2], [3, 3], [3, 3], [3, 3], [3, 2], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 4], [3, 3], [3, 3], [3, 3], [3, 2], [3, 4], [3, 3], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 1], [3, 3], [3, 4], [3, 3], [3, 4], [3, 3], [43, 4], [43, 1], [43, 1], [51, 1], [51, 2], [51, 2], [51, 3], [42, 3], [42, 3], [42, 4], [42, 4], [42, 3], [42, 2], [42, 1], [42, 1], [42, 0], [54, 2], [54, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [55, 1], [70, 2], [70, 2], [56, 1], [68, 2], [68, 4], [66, 10], [66, 10], [67, 2], [67, 3], [57, 5], [79, 6], [79, 5], [82, 2], [83, 4], [85, 6], [87, 2], [87, 1], [64, 4], [64, 3], [64, 3], [64, 2], [62, 15], [62, 15], [62, 13], [62, 13], [62, 14], [62, 14], [62, 12], [62, 12], [62, 10], [62, 9], [63, 8], [63, 7], [58, 4], [58, 4], [58, 4], [58, 4], [58, 4], [58, 4], [58, 4], [58, 4], [58, 4], [58, 4], [58, 4], [58, 4], [58, 6], [58, 6], [59, 3], [59, 3], [59, 5], [59, 5], [59, 2], [60, 6], [60, 6], [60, 6], [60, 6], [61, 7], [61, 4], [61, 4], [61, 9], [61, 9], [61, 9], [61, 5], [61, 5], [61, 9], [61, 11], [61, 7], [61, 11], [61, 11], [61, 9], [61, 9], [61, 11], [61, 11], [61, 17], [61, 17], [61, 9], [61, 9], [61, 7], [61, 4], [65, 3], [69, 2], [144, 2], [145, 2], [145, 0], [147, 1]],
		performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
			/* this == yyval */

			var $0 = $$.length - 1;
			switch (yystate) {
				case 1:
					this.$ = new IntValue(Number(toHalf(yytext, _$[$0])), new Location(_$[$0], _$[$0]));
					break;
				case 2:
					this.$ = new FloatValue(Number(toHalf(yytext, _$[$0])), new Location(_$[$0], _$[$0]));
					break;
				case 3:
					this.$ = new StringValue(escape_bracket(yytext), new Location(_$[$0], _$[$0]));
					break;
				case 4:
					this.$ = new BooleanValue(true, new Location(_$[$0], _$[$0]));
					break;
				case 5:
					this.$ = new BooleanValue(false, new Location(_$[$0], _$[$0]));
					break;
				case 6:
					this.$ = new Pow($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 7:
					this.$ = new Add($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 8:
					this.$ = new Sub($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 9:
					this.$ = new Mul($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 10:
					this.$ = new Div($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 11:
					this.$ = new DivInt($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 12:
					this.$ = new Mod($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 13:
					this.$ = new Minus($$[$0], new Location(_$[$0], _$[$0]));
					break;
				case 14:
					this.$ = new BitAnd($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 15:
					this.$ = new BitOr($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 16:
					this.$ = new BitXor($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 17:
					this.$ = new BitNot($$[$0], new Location(_$[$0 - 1], _$[$0]));
					break;
				case 18:
					this.$ = new BitLShift($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 19:
					this.$ = new BitRShift($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 20: case 58:
					this.$ = $$[$0 - 1];
					break;
				case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 29:
					this.$ = new Compare($$[$0 - 2], $$[$0 - 1], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 28:
					this.$ = new Compare($$[$0 - 3], 'not in', $$[$0], new Location(_$[$0 - 3], _$[$0]));
					break;
				case 30:
					this.$ = new And($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 31:
					this.$ = new Or($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 32:
					this.$ = new Not($$[$0], new Location(_$[$0 - 1], _$[$0]));
					break;
				case 33:
					this.$ = new Copy($$[$0 - 1], new Location(_$[$0 - 3], _$[$0]));
					break;
				case 34:
					this.$ = new Connect($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 35:
					this.$ = new ConvertInt($$[$0 - 1], new Location(_$[$0 - 3], _$[$0]));
					break;
				case 36:
					this.$ = new ConvertFloat($$[$0 - 1], new Location(_$[$0 - 3], _$[$0]));
					break;
				case 37:
					this.$ = new ConvertString($$[$0 - 1], new Location(_$[$0 - 3], _$[$0]));
					break;
				case 38:
					this.$ = new ConvertBool($$[$0 - 1], new Location(_$[$0 - 3], _$[$0]));
					break;
				case 39:
					this.$ = new CallFunction($$[$0 - 3], $$[$0 - 1], new Location(_$[$0 - 3], _$[$0 - 3]));
					break;
				case 40:
					this.$ = $$[$0];
					break;
				case 41:
					this.$ = new ArrayValue($$[$0 - 1], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 42:
					this.$ = new ArrayValue($$[$0 - 1], new Location(_$[$0 - 3], _$[$0]));
					break;
				case 43:
					this.$ = new DictionaryValue($$[$0 - 1], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 44:
					this.$ = new DictionaryValue($$[$0 - 1], new Location(_$[$0 - 3], _$[$0]));
					break;
				case 45:
					this.$ = new NumberOf($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 46:
					$$[$0 - 3].append($$[$0 - 1]); this.$ = $$[$0 - 3];
					break;
				case 47:
					this.$ = new Variable(toHalf($$[$0], _$[$0]), null, new Location(_$[$0], _$[$0]));
					break;
				case 48:
					this.$ = new UNDEFINED(yytext, new Location(_$[$0], _$[$0]));
					break;
				case 49:
					this.$ = new SliceValue(new NullValue(_$[$0]), new NullValue(_$[$0]), new Location(_$[$0], _$[$0]));
					break;
				case 50:
					this.$ = new SliceValue(new NullValue(_$[$0 - 1]), $$[$0], new Location(_$[$0 - 1], _$[$0 - 1]));
					break;
				case 51:
					this.$ = new SliceValue($$[$0 - 1], new NullValue(_$[$0 - 1]), new Location(_$[$0 - 1], _$[$0 - 1]));
					break;
				case 52:
					this.$ = new SliceValue($$[$0 - 2], $$[$0], new Location(_$[$0 - 2], _$[$0]));
					break;
				case 53: case 54:
					this.$ = $$[$0 - 2].concat($$[$0]);
					break;
				case 55: case 56:
					this.$ = $$[$0 - 3].concat($$[$0]);
					break;
				case 57:
					this.$ = $$[$0 - 2];
					break;
				case 59: case 60:
					this.$ = [$$[$0]];
					break;
				case 61: case 162:
					this.$ = [];
					break;
				case 62:
					if ($$[$0] != null) this.$ = $$[$0 - 1].concat($$[$0]);
					break;
				case 63: case 95:
					this.$ = [$$[$0]];
					break;
				case 79:
					this.$ = new NopStatement(new Location(_$[$0 - 1], _$[$0 - 1]));
					break;
				case 80:
					this.$ = new PauseStatement(new Location(_$[$0 - 1], _$[$0 - 1]));
					break;
				case 81: case 91:
					this.$ = null;
					break;
				case 82:
					this.$ = new DumpStatement(new Location(_$[$0 - 1], _$[$0 - 1]));
					break;
				case 83:
					this.$ = new DumpStatement(new Location(_$[$0 - 3], _$[$0 - 3]));
					break;
				case 84:
					this.$ = new DefineStep($$[$0 - 8], $$[$0 - 6], $$[$0 - 2], new Location(_$[$0 - 9], _$[$0 - 1]));
					break;
				case 85:
					this.$ = new DefineFunction($$[$0 - 8], $$[$0 - 6], $$[$0 - 2], new Location(_$[$0 - 9], _$[$0 - 1]));
					break;
				case 86:
					this.$ = new ExitStatement(new Location(_$[$0 - 1], _$[$0 - 1]));
					break;
				case 87:
					this.$ = new ReturnStatement($$[$0 - 2], new Location(_$[$0 - 2], _$[$0 - 1]));
					break;
				case 88:
					this.$ = new CallStep($$[$0 - 4], $$[$0 - 2], new Location(_$[$0 - 4], _$[$0 - 1]));
					break;
				case 89: case 93:
					this.$ = [$$[$0 - 4], $$[$0]];
					break;
				case 90:
					this.$ = [$$[$0 - 3], [$$[$0]]];
					break;
				case 92:
					this.$ = [null, $$[$0]];
					break;
				case 94:
					$$[$0 - 1].push($$[$0]); this.$ = $$[$0 - 1];
					break;
				case 96:
					tmp = [$$[$0 - 3]]; tmp = tmp.concat($$[$0 - 2]); tmp.push($$[$0 - 1]); this.$ = new If(tmp, new Location(_$[$0 - 3], _$[$0 - 1]))
					break;
				case 97:
					tmp = [$$[$0 - 2]]; tmp = tmp.concat($$[$0 - 1]); this.$ = new If(tmp, new Location(_$[$0 - 2], _$[$0]))
					break;
				case 98:
					tmp = [$$[$0 - 2]]; tmp.push($$[$0 - 1]); this.$ = new If(tmp, new Location(_$[$0 - 2], _$[$0]))
					break;
				case 99:
					tmp = [$$[$0 - 1]]; this.$ = new If(tmp, new Location(_$[$0 - 1], _$[$0 - 1]))
					break;
				case 100:
					this.$ = new ForInc($$[$0 - 14], $$[$0 - 12], $$[$0 - 10], $$[$0 - 8], $$[$0 - 2], new Location(_$[$0 - 14], _$[$0 - 1]));
					break;
				case 101:
					this.$ = new ForDec($$[$0 - 14], $$[$0 - 12], $$[$0 - 10], $$[$0 - 8], $$[$0 - 2], new Location(_$[$0 - 14], _$[$0 - 1]));
					break;
				case 102:
					this.$ = new ForInc($$[$0 - 12], $$[$0 - 10], $$[$0 - 8], new IntValue(1, new Location(_$[$0 - 12], _$[$0 - 12])), $$[$0 - 2], new Location(_$[$0 - 12], _$[$0 - 1]));
					break;
				case 103:
					this.$ = new ForDec($$[$0 - 12], $$[$0 - 10], $$[$0 - 8], new IntValue(1, new Location(_$[$0 - 12], _$[$0 - 12])), $$[$0 - 2], new Location(_$[$0 - 12], _$[$0 - 1]));
					break;
				case 104:
					this.$ = new ForInc($$[$0 - 13], $$[$0 - 11], $$[$0 - 9], $$[$0 - 7], $$[$0 - 2], new Location(_$[$0 - 13], _$[$0 - 1]));
					break;
				case 105:
					this.$ = new ForDec($$[$0 - 13], $$[$0 - 11], $$[$0 - 9], $$[$0 - 7], $$[$0 - 2], new Location(_$[$0 - 13], _$[$0 - 1]));
					break;
				case 106:
					this.$ = new ForInc($$[$0 - 11], $$[$0 - 9], $$[$0 - 7], new IntValue(1, new Location(_$[$0 - 11], _$[$0 - 11])), $$[$0 - 2], new Location(_$[$0 - 11], _$[$0 - 1]));
					break;
				case 107:
					this.$ = new ForDec($$[$0 - 11], $$[$0 - 9], $$[$0 - 7], new IntValue(1, new Location(_$[$0 - 11], _$[$0 - 11])), $$[$0 - 2], new Location(_$[$0 - 11], _$[$0 - 1]));
					break;
				case 108:
					this.$ = new ForIn($$[$0 - 9], $$[$0 - 7], $$[$0 - 2], new Location(_$[$0 - 9], _$[$0]));
					break;
				case 109:
					this.$ = new ForIn($$[$0 - 8], $$[$0 - 6], $$[$0 - 2], new Location(_$[$0 - 8], _$[$0]));
					break;
				case 110:
					this.$ = new While($$[$0 - 7], $$[$0 - 2], new Location(_$[$0 - 7], _$[$0 - 1]));
					break;
				case 111:
					this.$ = new While($$[$0 - 6], $$[$0 - 2], new Location(_$[$0 - 6], _$[$0 - 1]));
					break;
				case 112:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], null, new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 113:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '+', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 114:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '-', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 115:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '*', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 116:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '/', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 117:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '//', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 118:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '%', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 119:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '&', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 120:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '|', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 121:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '^', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 122:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '<<', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 123:
					this.$ = new Assign($$[$0 - 3], $$[$0 - 1], '>>', new Location(_$[$0 - 3], _$[$0 - 1]));
					break;
				case 124:
					this.$ = new Append($$[$0 - 5], $$[$0 - 3], new Location(_$[$0 - 5], _$[$0 - 1]));
					break;
				case 125:
					this.$ = new Extend($$[$0 - 5], $$[$0 - 3], new Location(_$[$0 - 5], _$[$0 - 1]));
					break;
				case 126:
					this.$ = new Output($$[$0 - 2], false, new Location(_$[$0 - 2], _$[$0 - 1]));
					break;
				case 127:
					this.$ = new Output($$[$0 - 2], true, new Location(_$[$0 - 2], _$[$0 - 1]));
					break;
				case 128:
					this.$ = new Output($$[$0 - 2], false, new Location(_$[$0 - 4], _$[$0 - 3]));
					break;
				case 129:
					this.$ = new Output($$[$0 - 2], true, new Location(_$[$0 - 4], _$[$0 - 3]));
					break;
				case 130:
					this.$ = new Newline(new Location(_$[$0 - 1], _$[$0 - 1]));
					break;
				case 131:
					this.$ = new Input($$[$0 - 5], typeOfValue.typeInt, new Location(_$[$0 - 5], _$[$0 - 2]));
					break;
				case 132:
					this.$ = new Input($$[$0 - 5], typeOfValue.typeFloat, new Location(_$[$0 - 5], _$[$0 - 2]));
					break;
				case 133:
					this.$ = new Input($$[$0 - 5], typeOfValue.typeString, new Location(_$[$0 - 5], _$[$0 - 2]));
					break;
				case 134:
					this.$ = new Input($$[$0 - 5], typeOfValue.typeBoolean, new Location(_$[$0 - 5], _$[$0 - 2]));
					break;
				case 135:
					this.$ = new GraphicStatement('gOpenWindow', [$$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 6], _$[$0 - 6]));
					break;
				case 136:
					this.$ = new GraphicStatement('gCloseWindow', [], new Location(_$[$0 - 3], _$[$0 - 3]));
					break;
				case 137:
					this.$ = new GraphicStatement('gClearWindow', [], new Location(_$[$0 - 3], _$[$0 - 3]));
					break;
				case 138:
					this.$ = new GraphicStatement('gSetLineColor', [$$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 8], _$[$0 - 8]));
					break;
				case 139:
					this.$ = new GraphicStatement('gSetFillColor', [$$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 8], _$[$0 - 8]));
					break;
				case 140:
					this.$ = new GraphicStatement('gSetTextColor', [$$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 8], _$[$0 - 8]));
					break;
				case 141:
					this.$ = new GraphicStatement('gSetLineWidth', [$$[$0 - 2]], new Location(_$[$0 - 4], _$[$0 - 4]));
					break;
				case 142:
					this.$ = new GraphicStatement('gSetFontSize', [$$[$0 - 2]], new Location(_$[$0 - 4], _$[$0 - 4]));
					break;
				case 143:
					this.$ = new GraphicStatement('gDrawText', [$$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 8], _$[$0 - 8]));
					break;
				case 144:
					this.$ = new GraphicStatement('gDrawLine', [$$[$0 - 8], $$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 10], _$[$0 - 10]));
					break;
				case 145:
					this.$ = new GraphicStatement('gDrawPoint', [$$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 6], _$[$0 - 6]));
					break;
				case 146:
					this.$ = new GraphicStatement('gDrawBox', [$$[$0 - 8], $$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 10], _$[$0 - 10]));
					break;
				case 147:
					this.$ = new GraphicStatement('gFillBox', [$$[$0 - 8], $$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 10], _$[$0 - 10]));
					break;
				case 148:
					this.$ = new GraphicStatement('gDrawCircle', [$$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 8], _$[$0 - 8]));
					break;
				case 149:
					this.$ = new GraphicStatement('gFillCircle', [$$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 8], _$[$0 - 8]));
					break;
				case 150:
					this.$ = new GraphicStatement('gDrawOval', [$$[$0 - 8], $$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 10], _$[$0 - 10]));
					break;
				case 151:
					this.$ = new GraphicStatement('gFillOval', [$$[$0 - 8], $$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 10], _$[$0 - 10]));
					break;
				case 152:
					this.$ = new GraphicStatement('gDrawArc', [$$[$0 - 14], $$[$0 - 12], $$[$0 - 10], $$[$0 - 8], $$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 16], _$[$0 - 16]));
					break;
				case 153:
					this.$ = new GraphicStatement('gFillArc', [$$[$0 - 14], $$[$0 - 12], $$[$0 - 10], $$[$0 - 8], $$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 16], _$[$0 - 16]));
					break;
				case 154:
					this.$ = new GraphicStatement('gBarplot', [$$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 8], _$[$0 - 8]));
					break;
				case 155:
					this.$ = new GraphicStatement('gLineplot', [$$[$0 - 6], $$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 8], _$[$0 - 8]));
					break;
				case 156:
					this.$ = new GraphicStatement('gDrawGraph', [$$[$0 - 4], $$[$0 - 2]], new Location(_$[$0 - 6], _$[$0 - 6]));
					break;
				case 157:
					this.$ = new GraphicStatement('gClearGraph', [], new Location(_$[$0 - 3], _$[$0 - 3]));
					break;
				case 158:
					this.$ = new SleepStatement($$[$0 - 2], new Location(_$[$0 - 2], _$[$0 - 2]));
					break;
				case 159:
					this.$ = new BreakStatement(new Location(_$[$0 - 1], _$[$0 - 1]));
					break;
				case 160:
					return $$[$0 - 1];
					break;
				case 161:
					this.$ = $$[$0 - 1].concat($$[$0]);
					break;
			}
		},
		table: [o($V0, [2, 162], { 144: 1, 145: 2 }), { 1: [3] }, o($V1, $V2, { 147: 4, 55: 5, 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU, 146: [1, 3] }), { 1: [2, 160] }, o($V0, [2, 161]), o($V0, [2, 163]), o($VV, [2, 64]), o($VV, [2, 65]), o($VV, [2, 66]), o($VV, [2, 67]), o($VV, [2, 68]), o($VV, [2, 69]), o($VV, [2, 70]), o($VV, [2, 71]), o($VV, [2, 72]), o($VV, [2, 73]), o($VV, [2, 74]), o($VV, [2, 75]), o($VV, [2, 76]), o($VV, [2, 77]), o($VV, [2, 78]), o($VV, $VW), o([9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 44, 49, 52, 53, 78, 88, 95, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], $VX, { 22: [1, 80] }), o($V1, $VY, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 52: $Vm1, 78: [1, 98], 88: [1, 94], 95: [1, 95], 97: [1, 96], 98: [1, 81], 99: [1, 82], 100: [1, 83], 101: [1, 84], 102: [1, 85], 103: [1, 86], 104: [1, 87], 105: [1, 88], 106: [1, 89], 107: [1, 90], 108: [1, 91], 109: [1, 92], 110: [1, 93], 142: [1, 97] }), { 53: $Vn1, 113: [1, 125], 114: [1, 126] }, { 22: [1, 128] }, { 22: [1, 129] }, { 46: [1, 130] }, { 22: [1, 131] }, { 22: [1, 132] }, { 22: [1, 133] }, { 22: [1, 134] }, { 22: [1, 135] }, { 22: [1, 136] }, { 22: [1, 137] }, { 22: [1, 138] }, { 22: [1, 139] }, { 22: [1, 140] }, { 22: [1, 141] }, { 22: [1, 142] }, { 22: [1, 143] }, { 22: [1, 144] }, { 22: [1, 145] }, { 22: [1, 146] }, { 22: [1, 147] }, { 22: [1, 148] }, { 22: [1, 149] }, { 22: [1, 150] }, { 22: [1, 151] }, { 22: [1, 152] }, { 22: [1, 153] }, { 75: $Vo1, 82: 156, 83: 155, 84: $Vp1, 85: 157, 86: $Vq1, 87: 154 }, { 41: [1, 161] }, { 41: [1, 162] }, { 46: [1, 163] }, { 22: [1, 165], 46: [1, 164] }, { 46: [1, 166] }, { 46: [1, 167] }, { 46: [1, 168] }, o($Vr1, [2, 1]), o($Vr1, [2, 2]), o($Vr1, [2, 3]), o($Vr1, [2, 4]), o($Vr1, [2, 5]), { 3: 169, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 171, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 172, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 173, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 22: [1, 174] }, { 22: $Vt1 }, { 22: $Vu1 }, { 22: $Vv1 }, { 22: $Vw1 }, o($Vr1, [2, 40], { 44: [1, 179] }), o($Vx1, $V2, { 43: 73, 51: 76, 42: 180, 3: 182, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 46: [1, 181], 47: $Vk, 50: $Vl, 52: $Vm }), o($Vy1, $V2, { 43: 73, 51: 76, 3: 182, 42: 183, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 46: [1, 184], 47: $Vk, 50: $Vl, 52: $Vm }), o($Vz1, [2, 60]), { 3: 185, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, o($VA1, [2, 48]), o($Vz1, [2, 49], { 43: 73, 3: 186, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl }), o($VB1, $V2, { 43: 73, 51: 76, 3: 182, 42: 187, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl, 52: $Vm }), { 3: 188, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 189, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 190, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 191, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 192, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 193, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 194, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 195, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 196, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 197, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 198, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 199, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 200, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: [1, 201], 38: [1, 202], 39: [1, 203], 40: [1, 204], 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 205, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 206, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 52: [1, 208], 93: [1, 207] }, { 46: [1, 209] }, { 46: [1, 210] }, { 3: 211, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 212, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 213, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 214, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 215, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 216, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 217, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 218, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 219, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 220, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 221, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 222, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 223, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 224, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 225, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 226, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 227, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 228, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 229, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 32: [1, 230] }, { 3: 231, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 232, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 233, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 234, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 235, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, o($Vz1, [2, 51], { 43: 73, 3: 236, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl }), { 46: [1, 237] }, { 46: [1, 238] }, o($Vz1, [2, 58], { 43: 73, 3: 239, 51: 240, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 46: [1, 241], 47: $Vk, 50: $Vl, 52: $Vm }), o($VB1, $V2, { 43: 73, 51: 76, 3: 182, 42: 242, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl, 52: $Vm }), o($VB1, $V2, { 43: 73, 51: 76, 3: 182, 42: 243, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl, 52: $Vm }), o($VV, [2, 130]), { 3: 244, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 23: [1, 245] }, { 23: [1, 246] }, { 3: 247, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 248, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 249, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 250, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 251, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 252, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 253, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 254, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 255, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 256, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 257, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 258, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 259, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 260, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 261, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 262, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 263, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 264, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 265, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 23: [1, 266] }, { 75: $Vo1, 82: 268, 83: 267, 84: $Vp1, 85: 269, 86: $Vq1 }, { 75: $Vo1, 82: 270 }, o($VV, [2, 99]), o($VC1, [2, 95]), { 52: [1, 271] }, { 46: [1, 272] }, { 3: 273, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 22: [1, 274] }, { 22: [1, 275] }, o($VV, [2, 86]), o($VV, [2, 82]), { 23: [1, 276] }, o($VV, [2, 159]), o($VV, [2, 79]), o($VV, [2, 80]), o($VD1, [2, 13], { 9: $VZ }), o($VA1, $VX, { 22: [1, 277] }), o($VD1, [2, 17], { 9: $VZ }), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 278], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, o($VE1, [2, 32], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 49: $Vl1 }), { 3: 279, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 280, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 281, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 282, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 283, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, o($Vx1, $V2, { 43: 73, 51: 76, 3: 182, 42: 284, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl, 52: $Vm }), { 45: [1, 285], 53: $Vn1 }, o($Vx1, $V2, { 43: 73, 51: 76, 3: 182, 42: 286, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl, 52: $Vm }), o([23, 45, 48, 53], $VY, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 52: $Vm1 }), { 48: [1, 287], 53: $Vn1 }, o($Vy1, $V2, { 43: 73, 51: 76, 3: 182, 42: 288, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl, 52: $Vm }), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 81: [1, 289] }, o($Vz1, [2, 50], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }), { 23: [1, 290], 53: $Vn1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 291], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 292], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 293], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 294], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 295], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 296], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 297], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 298], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 299], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 300], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 301], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 46: [1, 302], 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 88: [1, 303] }, { 22: $Vt1, 88: [1, 304] }, { 22: $Vu1, 88: [1, 305] }, { 22: $Vv1, 88: [1, 306] }, { 22: $Vw1, 88: [1, 307] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 89: [1, 308] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 96: [1, 309] }, { 52: [1, 310] }, { 46: [1, 311] }, o($VV, [2, 158]), o($VV, [2, 87]), o($VD1, [2, 6], { 9: $VZ }), o($VF1, [2, 7], { 9: $VZ, 12: $V01, 13: $V11, 14: $V21, 15: $V31 }), o($VF1, [2, 8], { 9: $VZ, 12: $V01, 13: $V11, 14: $V21, 15: $V31 }), o($VD1, [2, 9], { 9: $VZ }), o($VD1, [2, 10], { 9: $VZ }), o($VD1, [2, 11], { 9: $VZ }), o($VD1, [2, 12], { 9: $VZ }), o([16, 17, 18, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 45, 46, 48, 49, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], [2, 14], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 20: $V71, 21: $V81 }), o([17, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 45, 46, 48, 49, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], [2, 15], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 18: $V61, 20: $V71, 21: $V81 }), o([17, 18, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 45, 46, 48, 49, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], [2, 16], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 20: $V71, 21: $V81 }), o($VG1, [2, 18], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31 }), o($VG1, [2, 19], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31 }), o($VH1, [2, 21], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 49: $Vl1 }), o($VH1, [2, 22], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 49: $Vl1 }), o($VH1, [2, 23], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 49: $Vl1 }), o($VH1, [2, 24], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 49: $Vl1 }), o($VH1, [2, 25], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 49: $Vl1 }), o($VH1, [2, 26], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 49: $Vl1 }), o([23, 31, 33, 34, 36, 45, 46, 48, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], [2, 27], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 32: $Vh1, 49: $Vl1 }), { 3: 312, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, o($VH1, [2, 29], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 49: $Vl1 }), o($VE1, [2, 30], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 49: $Vl1 }), o([23, 34, 36, 45, 46, 48, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], [2, 31], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 49: $Vl1 }), o([23, 36, 45, 46, 48, 52, 53, 78, 81, 88, 89, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], [2, 34], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 49: $Vl1 }), o($VH1, [2, 45], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 49: $Vl1 }), o($Vz1, [2, 52], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }), o($VV, [2, 126]), o($VV, [2, 127]), o($Vz1, [2, 53], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 52: $Vm1 }), o($Vz1, [2, 54]), o($Vz1, [2, 57], { 43: 73, 3: 313, 51: 314, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl, 52: $Vm }), { 23: [1, 315], 53: $Vn1 }, { 23: [1, 316], 53: $Vn1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 317] }, { 46: [1, 318] }, { 46: [1, 319] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 320] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 321] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 322] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 323], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 324], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 325] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 326] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 327] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 328] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 329] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 330] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 331] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 332] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 333] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 334] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 335] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 336] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 337] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 338] }, { 46: [1, 339] }, { 75: $Vo1, 82: 340 }, o($VV, [2, 97]), o($VC1, [2, 94]), o($VV, [2, 98]), { 46: [1, 341] }, o($VV, [2, 91]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 81: [1, 342] }, o($VB1, $V2, { 43: 73, 51: 76, 3: 182, 42: 343, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl, 52: $Vm }), o($VB1, $V2, { 43: 73, 51: 76, 3: 182, 42: 344, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl, 52: $Vm }), { 46: [1, 345] }, o($VB1, $V2, { 43: 73, 51: 76, 3: 182, 42: 346, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 44: $Vi, 47: $Vk, 50: $Vl, 52: $Vm }), o($Vr1, [2, 20]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 347], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 348], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 349], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 350], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 351], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 45: [1, 352], 53: $Vn1 }, o($Vr1, [2, 41]), { 45: [1, 353], 53: $Vn1 }, o($Vr1, [2, 43]), { 48: [1, 354], 53: $Vn1 }, { 52: [1, 355] }, o([9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 49, 52, 53, 78, 88, 95, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 113, 114, 142], $VI1, { 46: [1, 356] }), o($VV, [2, 112]), o($VV, [2, 113]), o($VV, [2, 114]), o($VV, [2, 115]), o($VV, [2, 116]), o($VV, [2, 117]), o($VV, [2, 118]), o($VV, [2, 119]), o($VV, [2, 120]), o($VV, [2, 121]), o($VV, [2, 122]), o($VV, [2, 123]), { 111: [1, 357], 112: [1, 358] }, { 118: [1, 359] }, { 118: [1, 360] }, { 118: [1, 361] }, { 118: [1, 362] }, { 3: 363, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 52: [1, 365], 93: [1, 364] }, { 46: [1, 366] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 54: 367, 55: 368, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($VE1, [2, 28], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 49: $Vl1 }), o($Vz1, [2, 55], { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 52: $Vm1 }), o($Vz1, [2, 56]), { 46: [1, 369] }, { 46: [1, 370] }, { 3: 371, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, o($VV, [2, 136]), o($VV, [2, 137]), { 3: 372, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 373, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 374, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 46: [1, 375] }, { 46: [1, 376] }, { 3: 377, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 378, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 379, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 380, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 381, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 382, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 383, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 384, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 385, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 386, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 387, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 388, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 389, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 390, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, o($VV, [2, 157]), o($VV, [2, 96]), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 391, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 52: [1, 392] }, { 23: [1, 393], 53: $Vn1 }, { 23: [1, 394], 53: $Vn1 }, o($VV, [2, 83]), { 23: [1, 395], 53: $Vn1 }, o($Vr1, [2, 33]), o($Vr1, [2, 35]), o($Vr1, [2, 36]), o($Vr1, [2, 37]), o($Vr1, [2, 38]), o($VA1, [2, 46]), o($Vr1, [2, 42]), o($Vr1, [2, 44]), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 397, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: [1, 396], 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($VV, [2, 88]), { 46: [1, 398] }, { 46: [1, 399] }, { 46: [1, 400] }, { 46: [1, 401] }, { 46: [1, 402] }, { 46: [1, 403] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 90: [1, 404] }, { 52: [1, 405] }, { 46: [1, 406] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 407, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 408], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($VJ1, [2, 63]), o($VV, [2, 128]), o($VV, [2, 129]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 410], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 411] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 412] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 413] }, o($VV, [2, 141]), o($VV, [2, 142]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 414] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 415] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 416], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 417] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 418] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 419] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 420] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 421] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 422] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 423] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 424] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 425] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 426] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 427], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [2, 92], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 428] }, { 52: [1, 429] }, { 52: [1, 430] }, o($Vr1, $VI1), o($VC1, $VW, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 431, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 53: $V2, 113: $V2, 114: $V2, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($VC1, [2, 90]), o($VV, [2, 124]), o($VV, [2, 125]), o($VV, [2, 131]), o($VV, [2, 132]), o($VV, [2, 133]), o($VV, [2, 134]), { 3: 432, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl, 92: [1, 433], 94: [1, 434] }, { 46: [1, 435] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 436, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 437], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 438] }, o($VJ1, [2, 62]), { 46: [1, 439] }, { 3: 440, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 441, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 442, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 443, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 444, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 46: [1, 445] }, { 3: 446, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 447, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 448, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 449, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 450, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 451, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 452, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 453, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 454, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 455, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 46: [1, 456] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 457, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 458] }, { 46: [1, 459] }, o($VC1, [2, 89], { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 53: $V2, 113: $V2, 114: $V2, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 91: [1, 460] }, { 52: [1, 462], 93: [1, 461] }, { 52: [1, 464], 93: [1, 463] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 465, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 466], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 467] }, o($VV, [2, 111]), o($VV, [2, 135]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 468], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 469], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 470], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 471], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 472] }, o($VV, [2, 145]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 473] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 474] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 475], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 476], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 477] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 478] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 479] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 480] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 481], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 482], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, o($VV, [2, 156]), o($VC1, [2, 93], { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 53: $V2, 113: $V2, 114: $V2, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 483, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 484, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 92: [1, 485], 94: [1, 486] }, { 52: [1, 487] }, { 46: [1, 488] }, { 52: [1, 489] }, { 46: [1, 490] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 491], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 492] }, o($VV, [2, 110]), { 46: [1, 493] }, { 46: [1, 494] }, { 46: [1, 495] }, { 46: [1, 496] }, { 3: 497, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 498, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 499, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 46: [1, 500] }, { 46: [1, 501] }, { 3: 502, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 503, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 504, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 505, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 46: [1, 506] }, { 46: [1, 507] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 508], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 509], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 52: [1, 511], 93: [1, 510] }, { 52: [1, 513], 93: [1, 512] }, { 46: [1, 514] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 515, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 516] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 517, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 518] }, o($VV, [2, 109]), o($VV, [2, 138]), o($VV, [2, 139]), o($VV, [2, 140]), o($VV, [2, 143]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 519], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 520], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 521], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, o($VV, [2, 148]), o($VV, [2, 149]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 522], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 523], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 524] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 525] }, o($VV, [2, 154]), o($VV, [2, 155]), { 46: [1, 526] }, { 46: [1, 527] }, { 52: [1, 528] }, { 46: [1, 529] }, { 52: [1, 530] }, { 46: [1, 531] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 532, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 533], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 534, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 535], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($VV, [2, 108]), { 46: [1, 536] }, { 46: [1, 537] }, { 46: [1, 538] }, { 46: [1, 539] }, { 46: [1, 540] }, { 3: 541, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 542, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, o($VV, [2, 84]), o($VV, [2, 85]), { 46: [1, 543] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 544, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 545] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 546, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 547], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 548] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 549], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 550] }, o($VV, [2, 144]), o($VV, [2, 146]), o($VV, [2, 147]), o($VV, [2, 150]), o($VV, [2, 151]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 551] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 552] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 553, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 554], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 368, 54: 555, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 556], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 557] }, o($VV, [2, 106]), { 46: [1, 558] }, o($VV, [2, 107]), { 3: 559, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 560, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 561], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 562] }, o($V1, $V2, { 56: 6, 57: 7, 58: 8, 59: 9, 60: 10, 61: 11, 62: 12, 63: 13, 64: 14, 65: 15, 66: 16, 67: 17, 68: 18, 69: 19, 70: 20, 3: 23, 42: 24, 79: 51, 43: 73, 51: 76, 55: 409, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vh, 44: $Vi, 46: $Vj, 47: $Vk, 50: $Vl, 52: $Vm, 71: $Vn, 72: $Vo, 73: $Vp, 74: $Vq, 75: [1, 563], 76: $Vr, 77: $Vs, 80: $Vt, 115: $Vu, 116: $Vv, 117: $Vw, 119: $Vx, 120: $Vy, 121: $Vz, 122: $VA, 123: $VB, 124: $VC, 125: $VD, 126: $VE, 127: $VF, 128: $VG, 129: $VH, 130: $VI, 131: $VJ, 132: $VK, 133: $VL, 134: $VM, 135: $VN, 136: $VO, 137: $VP, 138: $VQ, 139: $VR, 140: $VS, 141: $VT, 143: $VU }), { 46: [1, 564] }, o($VV, [2, 102]), o($VV, [2, 103]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 565] }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1, 53: [1, 566] }, { 46: [1, 567] }, o($VV, [2, 104]), { 46: [1, 568] }, o($VV, [2, 105]), { 3: 569, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, { 3: 570, 4: $V3, 5: $V4, 6: $V5, 7: $V6, 8: $V7, 11: $V8, 19: $V9, 22: $Va, 31: $Vb, 35: $Vc, 37: $Vd, 38: $Ve, 39: $Vf, 40: $Vg, 41: $Vs1, 43: 73, 44: $Vi, 47: $Vk, 50: $Vl }, o($VV, [2, 100]), o($VV, [2, 101]), { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 571], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 9: $VZ, 10: $V_, 11: $V$, 12: $V01, 13: $V11, 14: $V21, 15: $V31, 16: $V41, 17: $V51, 18: $V61, 20: $V71, 21: $V81, 23: [1, 572], 24: $V91, 25: $Va1, 26: $Vb1, 27: $Vc1, 28: $Vd1, 29: $Ve1, 30: $Vf1, 31: $Vg1, 32: $Vh1, 33: $Vi1, 34: $Vj1, 36: $Vk1, 49: $Vl1 }, { 46: [1, 573] }, { 46: [1, 574] }, o($VV, [2, 152]), o($VV, [2, 153])],
		defaultActions: { 3: [2, 160] },
		parseError: function parseError(str, hash) {
			if (hash.recoverable) {
				this.trace(str);
			} else {
				var error = new Error(str);
				error.hash = hash;
				throw error;
			}
		},
		parse: function parse(input) {
			var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
			var args = lstack.slice.call(arguments, 1);
			var lexer = Object.create(this.lexer);
			var sharedState = { yy: {} };
			for (var k in this.yy) {
				if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
					sharedState.yy[k] = this.yy[k];
				}
			}
			lexer.setInput(input, sharedState.yy);
			sharedState.yy.lexer = lexer;
			sharedState.yy.parser = this;
			if (typeof lexer.yylloc == 'undefined') {
				lexer.yylloc = {};
			}
			var yyloc = lexer.yylloc;
			lstack.push(yyloc);
			var ranges = lexer.options && lexer.options.ranges;
			if (typeof sharedState.yy.parseError === 'function') {
				this.parseError = sharedState.yy.parseError;
			} else {
				this.parseError = Object.getPrototypeOf(this).parseError;
			}
			function popStack(n) {
				stack.length = stack.length - 2 * n;
				vstack.length = vstack.length - n;
				lstack.length = lstack.length - n;
			}
			var lex = function () {
				var token;
				token = lexer.lex() || EOF;
				if (typeof token !== 'number') {
					token = self.symbols_[token] || token;
				}
				return token;
			};
			var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
			while (true) {
				state = stack[stack.length - 1];
				if (this.defaultActions[state]) {
					action = this.defaultActions[state];
				} else {
					if (symbol === null || typeof symbol == 'undefined') {
						symbol = lex();
					}
					action = table[state] && table[state][symbol];
				}
				if (typeof action === 'undefined' || !action.length || !action[0]) {
					var errStr = '';
					expected = [];
					for (p in table[state]) {
						if (this.terminals_[p] && p > TERROR) {
							expected.push('\'' + this.terminals_[p] + '\'');
						}
					}
					if (lexer.showPosition) {
						errStr = yylineno + 1 + '行目に構文エラー：\n' + lexer.showPosition() + '\n\'' + (this.terminals_[symbol] || symbol) + '\'の近く（★のあたり）がおかしい';
					} else {
						errStr = yylineno + 1 + '行目に構文エラー：\n予期しない' + (symbol == EOF ? 'プログラムの終わり' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
					}
					this.parseError(errStr, {
						text: lexer.match,
						token: this.terminals_[symbol] || symbol,
						line: lexer.yylineno,
						loc: yyloc,
						expected: expected
					});
				}
				if (action[0] instanceof Array && action.length > 1) {
					throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
				}
				switch (action[0]) {
					case 1:
						stack.push(symbol);
						vstack.push(lexer.yytext);
						lstack.push(lexer.yylloc);
						stack.push(action[1]);
						symbol = null;
						if (!preErrorSymbol) {
							yyleng = lexer.yyleng;
							yytext = lexer.yytext;
							yylineno = lexer.yylineno;
							yyloc = lexer.yylloc;
							if (recovering > 0) {
								recovering--;
							}
						} else {
							symbol = preErrorSymbol;
							preErrorSymbol = null;
						}
						break;
					case 2:
						len = this.productions_[action[1]][1];
						yyval.$ = vstack[vstack.length - len];
						yyval._$ = {
							first_line: lstack[lstack.length - (len || 1)].first_line,
							last_line: lstack[lstack.length - 1].last_line,
							first_column: lstack[lstack.length - (len || 1)].first_column,
							last_column: lstack[lstack.length - 1].last_column
						};
						if (ranges) {
							yyval._$.range = [
								lstack[lstack.length - (len || 1)].range[0],
								lstack[lstack.length - 1].range[1]
							];
						}
						r = this.performAction.apply(yyval, [
							yytext,
							yyleng,
							yylineno,
							sharedState.yy,
							action[1],
							vstack,
							lstack
						].concat(args));
						if (typeof r !== 'undefined') {
							return r;
						}
						if (len) {
							stack = stack.slice(0, -1 * len * 2);
							vstack = vstack.slice(0, -1 * len);
							lstack = lstack.slice(0, -1 * len);
						}
						stack.push(this.productions_[action[1]][0]);
						vstack.push(yyval.$);
						lstack.push(yyval._$);
						newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
						stack.push(newState);
						break;
					case 3:
						return true;
				}
			}
			return true;
		}
	};

	const typeOfValue =
	{
		typeInt: 1,
		typeFloat: 2,
		typeString: 3,
		typeBoolean: 4,
		typeArray: 5
	};
	function toHalf(s, token) {
		if (setting.zenkaku_mode == 1) {
			if (/[Ａ-Ｚａ-ｚ０-９．−]/.exec(s))
				throw { message: token.first_line + "行目に全角文字が間違って使われています" };
		}
		return s.replace(/[Ａ-Ｚａ-ｚ０-９．−]/g, function (s) {
			return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
		}
		);
	}
	function escape_bracket(s) {
		if (/^".*"$/.exec(s)) return s.substr(1, s.length - 2).replace(/\\\"/g, "\"");
		else if (/^'.*'$/.exec(s)) return s.substr(1, s.length - 2).replace(/\\'/g, "'");
		else return s.substr(1, s.length - 2);
	}

	/* generated by jison-lex 0.3.4 */
	var lexer = (function () {
		var lexer = ({

			EOF: 1,

			parseError: function parseError(str, hash) {
				if (this.yy.parser) {
					this.yy.parser.parseError(str, hash);
				} else {
					throw new Error(str);
				}
			},

			// resets the lexer, sets new input
			setInput: function (input, yy) {
				this.yy = yy || this.yy || {};
				this._input = input;
				this._more = this._backtrack = this.done = false;
				this.yylineno = this.yyleng = 0;
				this.yytext = this.matched = this.match = '';
				this.conditionStack = ['INITIAL'];
				this.yylloc = {
					first_line: 1,
					first_column: 0,
					last_line: 1,
					last_column: 0
				};
				if (this.options.ranges) {
					this.yylloc.range = [0, 0];
				}
				this.offset = 0;
				return this;
			},

			// consumes and returns one char from the input
			input: function () {
				var ch = this._input[0];
				this.yytext += ch;
				this.yyleng++;
				this.offset++;
				this.match += ch;
				this.matched += ch;
				var lines = ch.match(/(?:\r\n?|\n).*/g);
				if (lines) {
					this.yylineno++;
					this.yylloc.last_line++;
				} else {
					this.yylloc.last_column++;
				}
				if (this.options.ranges) {
					this.yylloc.range[1]++;
				}

				this._input = this._input.slice(1);
				return ch;
			},

			// unshifts one char (or a string) into the input
			unput: function (ch) {
				var len = ch.length;
				var lines = ch.split(/(?:\r\n?|\n)/g);

				this._input = ch + this._input;
				this.yytext = this.yytext.substr(0, this.yytext.length - len);
				//this.yyleng -= len;
				this.offset -= len;
				var oldLines = this.match.split(/(?:\r\n?|\n)/g);
				this.match = this.match.substr(0, this.match.length - 1);
				this.matched = this.matched.substr(0, this.matched.length - 1);

				if (lines.length - 1) {
					this.yylineno -= lines.length - 1;
				}
				var r = this.yylloc.range;

				this.yylloc = {
					first_line: this.yylloc.first_line,
					last_line: this.yylineno + 1,
					first_column: this.yylloc.first_column,
					last_column: lines ?
						(lines.length === oldLines.length ? this.yylloc.first_column : 0)
						+ oldLines[oldLines.length - lines.length].length - lines[0].length :
						this.yylloc.first_column - len
				};

				if (this.options.ranges) {
					this.yylloc.range = [r[0], r[0] + this.yyleng - len];
				}
				this.yyleng = this.yytext.length;
				return this;
			},

			// When called from action, caches matched text and appends it on next action
			more: function () {
				this._more = true;
				return this;
			},

			// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
			reject: function () {
				if (this.options.backtrack_lexer) {
					this._backtrack = true;
				} else {
					return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
						text: "",
						token: null,
						line: this.yylineno
					});

				}
				return this;
			},

			// retain first n characters of the match
			less: function (n) {
				this.unput(this.match.slice(n));
			},

			// displays already matched input, i.e. for error messages
			pastInput: function () {
				var past = this.matched.substr(0, this.matched.length - this.match.length);
				return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
			},

			// displays upcoming input, i.e. for error messages
			upcomingInput: function () {
				var next = this.match;
				if (next.length < 20) {
					next += this._input.substr(0, 20 - next.length);
				}
				return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
			},

			// displays the character position where the lexing error occurred, i.e. for error messages
			showPosition: function () {
				var re = /■/g;
				var pre = this.pastInput();
				var c = new Array(pre.length + 1).join("-");
				//        return pre + this.upcomingInput() + "\n" + c + "^";
				return pre.replace(re, '') + '★' + this.upcomingInput().replace(re, '') + '...\n';
			},

			// test the lexed token: return FALSE when not a match, otherwise return token
			test_match: function (match, indexed_rule) {
				var token,
					lines,
					backup;

				if (this.options.backtrack_lexer) {
					// save context
					backup = {
						yylineno: this.yylineno,
						yylloc: {
							first_line: this.yylloc.first_line,
							last_line: this.last_line,
							first_column: this.yylloc.first_column,
							last_column: this.yylloc.last_column
						},
						yytext: this.yytext,
						match: this.match,
						matches: this.matches,
						matched: this.matched,
						yyleng: this.yyleng,
						offset: this.offset,
						_more: this._more,
						_input: this._input,
						yy: this.yy,
						conditionStack: this.conditionStack.slice(0),
						done: this.done
					};
					if (this.options.ranges) {
						backup.yylloc.range = this.yylloc.range.slice(0);
					}
				}

				if (match[0].match(/^■$/)) this.yylineno--; // added
				lines = match[0].match(/(?:\r\n?|\n).*/g);
				if (lines) {
					this.yylineno += lines.length;
				}
				this.yylloc = {
					first_line: this.yylloc.last_line,
					last_line: this.yylineno + 1,
					first_column: this.yylloc.last_column,
					last_column: lines ?
						lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
						this.yylloc.last_column + match[0].length
				};
				this.yytext += match[0];
				this.match += match[0];
				this.matches = match;
				this.yyleng = this.yytext.length;
				if (this.options.ranges) {
					this.yylloc.range = [this.offset, this.offset += this.yyleng];
				}
				this._more = false;
				this._backtrack = false;
				this._input = this._input.slice(match[0].length);
				this.matched += match[0];
				token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
				if (this.done && this._input) {
					this.done = false;
				}
				if (token) {
					return token;
				} else if (this._backtrack) {
					// recover context
					for (var k in backup) {
						this[k] = backup[k];
					}
					return false; // rule action called reject() implying the next rule should be tested instead.
				}
				return false;
			},

			// return next match in input
			next: function () {
				if (this.done) {
					return this.EOF;
				}
				if (!this._input) {
					this.done = true;
				}

				var token,
					match,
					tempMatch,
					index;
				if (!this._more) {
					this.yytext = '';
					this.match = '';
				}
				var rules = this._currentRules();
				for (var i = 0; i < rules.length; i++) {
					tempMatch = this._input.match(this.rules[rules[i]]);
					if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
						match = tempMatch;
						index = i;
						if (this.options.backtrack_lexer) {
							token = this.test_match(tempMatch, rules[i]);
							if (token !== false) {
								return token;
							} else if (this._backtrack) {
								match = false;
								continue; // rule action called reject() implying a rule MISmatch.
							} else {
								// else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
								return false;
							}
						} else if (!this.options.flex) {
							break;
						}
					}
				}
				if (match) {
					token = this.test_match(match, rules[index]);
					if (token !== false) {
						return token;
					}
					// else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
					return false;
				}
				if (this._input === "") {
					return this.EOF;
				} else {
					return this.parseError((this.yylineno + 1) + '行目にエラー。\n★の近くに不明なテキスト。\n' + this.showPosition(), {
						text: "",
						token: null,
						line: this.yylineno
					});
				}
			},

			// return next match that has a token
			lex: function lex() {
				var r = this.next();
				if (r) {
					return r;
				} else {
					return this.lex();
				}
			},

			// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
			begin: function begin(condition) {
				this.conditionStack.push(condition);
			},

			// pop the previously active lexer condition state off the condition stack
			popState: function popState() {
				var n = this.conditionStack.length - 1;
				if (n > 0) {
					return this.conditionStack.pop();
				} else {
					return this.conditionStack[0];
				}
			},

			// produce the lexer rule set which is active for the currently active lexer condition state
			_currentRules: function _currentRules() {
				if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
					return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
				} else {
					return this.conditions["INITIAL"].rules;
				}
			},

			// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
			topState: function topState(n) {
				n = this.conditionStack.length - 1 - Math.abs(n || 0);
				if (n >= 0) {
					return this.conditionStack[n];
				} else {
					return "INITIAL";
				}
			},

			// alias for begin(condition)
			pushState: function pushState(condition) {
				this.begin(condition);
			},

			// return the number of states currently on the stack
			stateStackSize: function stateStackSize() {
				return this.conditionStack.length;
			},
			options: {},
			performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
				var YYSTATE = YY_START;
				switch ($avoiding_name_collisions) {
					case 0: return 40;
						break;
					case 1: return 7;
						break;
					case 2: return 8;
						break;
					case 3: return 6;
						break;
					case 4: return 5;
						break;
					case 5: return 4;
						break;
					case 6: return 50;
						break;
					case 7: return 24
						break;
					case 8: return 98;
						break;
					case 9: return 99;
						break;
					case 10: return 100;
						break;
					case 11: return 101;
						break;
					case 12: return 102;
						break;
					case 13: return 103;
						break;
					case 14: return 104;
						break;
					case 15: return 105;
						break;
					case 16: return 106;
						break;
					case 17: return 107;
						break;
					case 18: return 108;
						break;
					case 19: return 109;
						break;
					case 20: return 10;
						break;
					case 21: return 11;
						break;
					case 22: return 9;
						break;
					case 23: return 12;
						break;
					case 24: return 14
						break;
					case 25: return 13
						break;
					case 26: return 15;
						break;
					case 27: return 22;
						break;
					case 28: return 23;
						break;
					case 29: return 22;
						break;
					case 30: return 23;
						break;
					case 31: return 44;
						break;
					case 32: return 45;
						break;
					case 33: return 44;
						break;
					case 34: return 45;
						break;
					case 35: return 47;
						break;
					case 36: return 48;
						break;
					case 37: return 47;
						break;
					case 38: return 48;
						break;
					case 39: return 28;
						break;
					case 40: return 29;
						break;
					case 41: return 21;
						break;
					case 42: return 20;
						break;
					case 43: return 26;
						break;
					case 44: return 27;
						break;
					case 45: return 25;
						break;
					case 46: return 16;
						break;
					case 47: return 17;
						break;
					case 48: return 18;
						break;
					case 49: return 19;
						break;
					case 50: return 53;
						break;
					case 51: return 52
						break;
					case 52: return 33;
						break;
					case 53: return 34;
						break;
					case 54: return 31;
						break;
					case 55: return 32;
						break;
					case 56: return 75
						break;
					case 57: return 114;
						break;
					case 58: return 113;
						break;
					case 59: return 113;
						break;
					case 60: return 116;
						break;
					case 61: return 115;
						break;
					case 62: return 115;
						break;
					case 63: return 118;
						break;
					case 64: return 80;
						break;
					case 65: return 81;
						break;
					case 66: return 84;
						break;
					case 67: return 86;
						break;
					case 68: return 97;
						break;
					case 69: return 143;
						break;
					case 70: return 143;
						break;
					case 71: return 143;
						break;
					case 72: return 77;
						break;
					case 73: return 74;
						break;
					case 74: return 76;
						break;
					case 75: return 78;
						break;
					case 76: return 30;
						break;
					case 77: return 96;
						break;
					case 78: return 110;
						break;
					case 79: return 88;
						break;
					case 80: return 49;
						break;
					case 81: return 89;
						break;
					case 82: return 90;
						break;
					case 83: return 91;
						break;
					case 84: return 92;
						break;
					case 85: return 94;
						break;
					case 86: return 92;
						break;
					case 87: return 94;
						break;
					case 88: return 93;
						break;
					case 89: return 93;
						break;
					case 90: return 93;
						break;
					case 91: return 95;
						break;
					case 92: return 37;
						break;
					case 93: return 38;
						break;
					case 94: return 39;
						break;
					case 95: return 36;
						break;
					case 96: return 36;
						break;
					case 97: return 111;
						break;
					case 98: return 112;
						break;
					case 99: return 111;
						break;
					case 100: return 112;
						break;
					case 101: return 119;
						break;
					case 102: return 119;
						break;
					case 103: return 120;
						break;
					case 104: return 120;
						break;
					case 105: return 121;
						break;
					case 106: return 121;
						break;
					case 107: return 122;
						break;
					case 108: return 122;
						break;
					case 109: return 123;
						break;
					case 110: return 123;
						break;
					case 111: return 124;
						break;
					case 112: return 124;
						break;
					case 113: return 125;
						break;
					case 114: return 125;
						break;
					case 115: return 126;
						break;
					case 116: return 126;
						break;
					case 117: return 127;
						break;
					case 118: return 127;
						break;
					case 119: return 128;
						break;
					case 120: return 128;
						break;
					case 121: return 129;
						break;
					case 122: return 129;
						break;
					case 123: return 130;
						break;
					case 124: return 130;
						break;
					case 125: return 131;
						break;
					case 126: return 131;
						break;
					case 127: return 132;
						break;
					case 128: return 132;
						break;
					case 129: return 133;
						break;
					case 130: return 133;
						break;
					case 131: return 134;
						break;
					case 132: return 134;
						break;
					case 133: return 135;
						break;
					case 134: return 135;
						break;
					case 135: return 136;
						break;
					case 136: return 136;
						break;
					case 137: return 137;
						break;
					case 138: return 137;
						break;
					case 139: return 138;
						break;
					case 140: return 138;
						break;
					case 141: return 139;
						break;
					case 142: return 139;
						break;
					case 143: return 140;
						break;
					case 144: return 140;
						break;
					case 145: return 141;
						break;
					case 146: return 141;
						break;
					case 147: return 142;
						break;
					case 148: return 73;
						break;
					case 149: return 117;
						break;
					case 150: return 71;
						break;
					case 151: return 72;
						break;
					case 152: return 72;
						break;
					case 153: return 35;
						break;
					case 154: return 35;
						break;
					case 155: return 41;
						break;
					case 156: return 46;
						break;
					case 157: return 146;
						break;
					case 158: return 46;
						break;
					case 159:/* skip whitespace */
						break;
				}
			},
			rules: [/^(?:真偽)/, /^(?:(\b(真|[Tt][Rr][Uu][Ee])\b))/, /^(?:(\b(偽|[Ff][Aa][Ll][Ss][Ee])\b))/, /^(?:(「[^」]*」|'(\\'|[^\'])*'|"(\\"|[^"])*"))/, /^(?:((([0０]|(([1-9１-９])([0-9０-９])*))([.．]([0-9０-９])+)?[eE][+-]?([0０]|(([1-9１-９])([0-9０-９])*)))|(([0０]|(([1-9１-９])([0-9０-９])*))[.．]([0-9０-９])+)))/, /^(?:([0０]|(([1-9１-９])([0-9０-９])*)))/, /^(?:(《[^》]*》))/, /^(?:([\=＝][\=＝]))/, /^(?:([\=＝]))/, /^(?:([\+＋][\=＝]))/, /^(?:([\-ー−‐][\=＝]))/, /^(?:([\*＊×][\=＝]))/, /^(?:([/／][\=＝]))/, /^(?:(([/／][/／]|÷)[\=＝]))/, /^(?:([%％][\=＝]))/, /^(?:([&＆][\=＝]))/, /^(?:([\|｜][\=＝]))/, /^(?:([\^＾][\=＝]))/, /^(?:([<＜][<＜][\=＝]))/, /^(?:([>＞][>＞][\=＝]))/, /^(?:([+＋]))/, /^(?:([-ー−‐]))/, /^(?:([\*＊×][\*＊×]))/, /^(?:([\*＊×]))/, /^(?:([/／][/／]|÷))/, /^(?:([/／]))/, /^(?:([%％]))/, /^(?:\()/, /^(?:\))/, /^(?:（)/, /^(?:）)/, /^(?:\[)/, /^(?:\])/, /^(?:［)/, /^(?:］)/, /^(?:\{)/, /^(?:\})/, /^(?:｛)/, /^(?:｝)/, /^(?:(([>＞][=＝])|≧))/, /^(?:(([<＜][=＝])|≦))/, /^(?:([>＞][>＞]))/, /^(?:([<＜][<＜]))/, /^(?:([>＞]))/, /^(?:([<＜]))/, /^(?:(([!！][=＝])|([<＜][>＞])|≠))/, /^(?:([&＆]))/, /^(?:([\|｜]))/, /^(?:([\^＾]))/, /^(?:([~〜]))/, /^(?:([，,、]))/, /^(?:([:：]))/, /^(?:(\b[Aa][Nn][Dd]\b))/, /^(?:(\b[Oo][Rr]\b))/, /^(?:(\b[Nn][Oo][Tt]\b))/, /^(?:(\b[Ii][Nn]\b))/, /^(?:■)/, /^(?:を(表示|印刷|出力)する)/, /^(?:を改行無しで(表示|印刷|出力)する)/, /^(?:を改行なしで(表示|印刷|出力)する)/, /^(?:(表示|印刷|出力)する)/, /^(?:改行無しで(表示|印刷|出力)する)/, /^(?:改行なしで(表示|印刷|出力)する)/, /^(?:入力する)/, /^(?:もし)/, /^(?:ならば)/, /^(?:そうでなければ)/, /^(?:そうでなくもし)/, /^(?:の間)/, /^(?:繰り返しを抜ける)/, /^(?:繰返しを抜ける)/, /^(?:くりかえしを抜ける)/, /^(?:手続きを抜ける)/, /^(?:手続き)/, /^(?:関数)/, /^(?:を返す)/, /^(?:の中に)/, /^(?:について)/, /^(?:に)/, /^(?:を)/, /^(?:個の)/, /^(?:から)/, /^(?:まで)/, /^(?:ずつ)/, /^(?:増やしながら)/, /^(?:減らしながら)/, /^(?:増やしつつ)/, /^(?:減らしつつ)/, /^(?:くりかえす)/, /^(?:繰り返す)/, /^(?:繰返す)/, /^(?:の要素)/, /^(?:整数)/, /^(?:実数)/, /^(?:文字列)/, /^(?:と([，,、]))/, /^(?:と)/, /^(?:追加する)/, /^(?:連結する)/, /^(?:追加)/, /^(?:連結)/, /^(?:描画領域開く)/, /^(?:gOpenWindow\b)/, /^(?:描画領域閉じる)/, /^(?:gCloseWindow\b)/, /^(?:描画領域全消去)/, /^(?:gClearWindow\b)/, /^(?:線色設定)/, /^(?:gSetLineColor\b)/, /^(?:塗色設定)/, /^(?:gSetFillColor\b)/, /^(?:文字色設定)/, /^(?:gSetTextColor\b)/, /^(?:線太さ設定)/, /^(?:gSetLineWidth\b)/, /^(?:文字サイズ設定)/, /^(?:gSetFontSize\b)/, /^(?:文字描画)/, /^(?:gDrawText\b)/, /^(?:線描画)/, /^(?:gDrawLine\b)/, /^(?:点描画)/, /^(?:gDrawPoint\b)/, /^(?:矩形描画)/, /^(?:gDrawBox\b)/, /^(?:矩形塗描画)/, /^(?:gFillBox\b)/, /^(?:円描画)/, /^(?:gDrawCircle\b)/, /^(?:円塗描画)/, /^(?:gFillCircle\b)/, /^(?:楕円描画)/, /^(?:gDrawOval\b)/, /^(?:楕円塗描画)/, /^(?:gFillOval\b)/, /^(?:弧描画)/, /^(?:gDrawArc\b)/, /^(?:弧塗描画)/, /^(?:gFillArc\b)/, /^(?:棒グラフ描画)/, /^(?:gBarplot\b)/, /^(?:線グラフ描画)/, /^(?:gLinePlot\b)/, /^(?:グラフ描画)/, /^(?:gDrawGraph\b)/, /^(?:グラフ消去)/, /^(?:gClearGraph\b)/, /^(?:ミリ秒待つ)/, /^(?:変数を確認する)/, /^(?:改行する)/, /^(?:何もしない)/, /^(?:一時停止する)/, /^(?:一時停止)/, /^(?:copy\b)/, /^(?:複製)/, /^(?:(([_a-zA-Zａ-ｚＡ-Ｚ])([_a-zA-Z0-9ａ-ｚＡ-Ｚ０-９])*))/, /^(?:([#＃♯].*(\r|\n|\r\n)))/, /^(?:$)/, /^(?:(\r\n|\r|\n))/, /^(?:([ 　]))/],
			conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159], "inclusive": true } }
		});
		return lexer;
	})();
	parser.lexer = lexer;
	function Parser() {
		this.yy = {};
	}
	Parser.prototype = parser; parser.Parser = Parser;
	return new Parser;
})();

// if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
// 	exports.parser = dncl;
// 	exports.Parser = dncl.Parser;
// 	exports.parse = function () { return dncl.parse.apply(dncl, arguments); };
// 	exports.main = function commonjsMain(args) {
// 		if (!args[1]) {
// 			console.log('Usage: ' + args[0] + ' FILE');
// 			process.exit(1);
// 		}
// 		var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
// 		return exports.parser.parse(source);
// 	};
// 	if (typeof module !== 'undefined' && require.main === module) {
// 		exports.main(process.argv.slice(1));
// 	}
// }

var setting =
{
	zenkaku_mode: 0,
	// 変数名や数値，数値の入力で全角が使われた場合の処理
	// 0 内部的に強制的に半角に直してエラーを出さない
	// 1 エラーを出して停止する

	quiz_mode: 0,
	// 問題を表示するかどうか
	// 0 表示しない
	// 1 表示する

	graphic_command: 0,
	// グラフィックコマンドが英語か日本語か
	// 0 日本語
	// 1 英語
};

/**
 * @returns {string}
 * @param {string} code
 */
function python_to_dncl(code) {
	var python_lines = code.split('\n');
	while (python_lines.length > 1 &&
		/^[ 　]*$/.exec(python_lines[python_lines.length - 1]) &&
		!(/[:：]$/.exec(python_lines[python_lines.length - 2])))
		python_lines.pop();
	python_lines.push('');
	var dncl_lines = [];
	var pre_spaces = [0];
	var wait_for_indent = false;
	var ignore_spaces = false;
	for (var i = 0; i < python_lines.length; i++) {
		var line = python_lines[i].trimRight();
		var result = /^([ 　]*)(.*)$/.exec(line);
		if (i < python_lines.length - 1 && result && !result[2]) {
			dncl_lines.push(line);
			continue;
		}
		if (result) {
			var spaces = count_spaces(result[1]);
			if (/^[ 　]*[#＃]/.exec(result[2])) {
				dncl_lines.push(line);
				continue;
			}
			if (wait_for_indent) {
				if (!ignore_spaces && spaces <= pre_spaces[0]) throw { "message": (i + 1) + "行目行頭の空白の数がおかしいです" };
				pre_spaces.unshift(spaces);
			}
			var deindent = false;
			while (!ignore_spaces && spaces < pre_spaces[0]) {
				var indent = pre_spaces.shift();
				if (indent == null) throw { "message": (i + 1) + "行目行頭の空白の数がおかしいです2" };
				if (spaces <= indent) {
					if (spaces < indent && (deindent || !/^(そうでなければ|そうでなくもし.*)[：:]$/.exec(result[2]))) {
						dncl_lines.push('■');
					}
					deindent = true;
				}
				else throw { "message": (i + 1) + "行目行頭の空白の数がおかしいです" };
			}
			if (!ignore_spaces && spaces > pre_spaces[0]) throw { "message": (i + 1) + "行目行頭の空白の数がおかしいです" };
			wait_for_indent = /[：:]$/.exec(result[2]) ? true : false;
			ignore_spaces = /[,，、\[{]$/.exec(result[2]) ? true : false;
		}
		dncl_lines.push(line);
	}
	return dncl_lines.join('\n') + '\n';
}

function count_spaces(s) {
	var spaces = 0;
	for (var i = 0; i < s.length; i++)
		spaces += s[i] == ' ' ? 1 : 2;
	return spaces;
}

"use strict"

const typeOfValue =
{
	typeInt: 1,
	typeFloat: 2,
	typeString: 3,
	typeBoolean: 4,
	typeArray: 5
};

var graphColor = [
	'#c00000', '#00c000', '#0000c0', '#007070', '#700070', '#707000'
];

const nameOfType = ['', '整数', '実数', '文字列', '真偽', '配列'];

var code = null;		// コードを積む（関数・手続き単位で）
var varTables = [];		// 変数テーブルを積む
var myFuncs = {};		// プログラム中で定義される関数・手続き
var run_flag = false, step_flag = false, editable_flag = true;
var flowchart = null;
var textarea = null;
var context = null;
var current_line = -1;
var wait_time = 0;
var flowchart_display = false;
var converting = false;
var dirty = null;
var timeouts = [];
var selected_quiz = -1, selected_quiz_case = -1, selected_quiz_input = 0, selected_quiz_output = 0;
var output_str = '';
var test_limit_time = 0;
var fontsize = 16;
var python_lib = {};
var editor = null;
let canvas = null;

/**
 * parsed...すべての親クラス
 */
class parsedCode {
	/**
	 * @constructor
	 * @param {Array<Statement>} statementlist
	 */
	constructor(statementlist) { this.stack = [{ statementlist: statementlist, index: 0 }] }
	makePython() {
		python_lib = {}	// クリアする
		var code = ''
		var libs = '';
		for (var i = 0; i < this.stack[0].statementlist.length; i++) // 関数・手続き宣言を先に
		{
			var state = this.stack[0].statementlist[i];
			if (state && (state instanceof DefineFunction || state instanceof DefineStep)) code += state.makePython(0) + "\n\n";
		}
		for (var i = 0; i < this.stack[0].statementlist.length; i++)	// メインルーチン
		{
			var state = this.stack[0].statementlist[i];
			if (state && !(state instanceof DefineFunction || state instanceof DefineStep)) code += state.makePython(0);
		}
		for (var lib in python_lib) libs += "import " + lib + "\n";
		return libs + code;
	}
}

/** parsedMainRoutineクラス
 * @extends parsedCode
 */
class parsedMainRoutine extends parsedCode {
	/**
	 * @constructor
	 * @param {Array<Statement>} statementlist
	 */
	constructor(statementlist) { super(statementlist); }
}

/** parsedFunctionクラス
 * @extends parsedCode
 */
class parsedFunction extends parsedCode {
	/**
	 * @constructor
	 * @param {Array<Statement>} statementlist
	 */
	constructor(statementlist) {
		super(statementlist);
	}
}

/** parsedStepクラス
 * @extends parsedCode
 */
class parsedStep extends parsedCode {
	/**
	 * @constructor
	 * @param {Array<Statement>} statementlist
	 */
	constructor(statementlist) { super(statementlist); }
}

/**
 * 変数テーブルのクラス
 */
class varTable {
	/**
	 * @constructor
	 */
	constructor() {
		this.vars = {};
	}
	/**
	 *
	 * @param {Array<string>} oldvars
	 * @returns {Array} 持っている変数名をoldvarsに追加してソートしたもの
	 */
	varnames(oldvars) {
		var names = oldvars.concat();
		for (var name in this.vars)
			if (names.indexOf(name) < 0) names.push(name);
		return names.sort();
	}
}

/**
 * varnameという名前の変数を持つ変数テーブルを返す
 * @param {string} varname
 * @returns {varTable} varnameを持つvarTable
 */
function findVarTable(varname) {
	return varname in varTables[0].vars ? varTables[0] : null;
}

/**
 * コードをフローチャートに反映させる
 */
function codeChange() {
}

/************************************************************************************ユーティリティ関数 */

/**
 * 有限な値であるか
 * @param {number|string} v
 * @returns {boolean} vが有限な値であるか
 */
function isFinite(v) {
	return Number.isFinite(v);
	// return !isNaN(v) && v != Number.POSITIVE_INFINITY && v != Number.NEGATIVE_INFINITY;
}

/**
 * 整数で表せる値であるか
 * @param {number} v
 * @returns {boolean} vが整数で表せる値であるか
 */
function isSafeInteger(v) {
	return Number.isSafeInteger(v);
	// return !isNaN(v) && v == Math.floor(v) && v <= 9007199254740991 && v >= -9007199254740991;
}

/**
 * 整数であるか
 * @param {number} v
 * @returns {boolean} vが整数であるか
 */
function isInteger(v) {
	return Number.isInteger(v);
	// return isFinite(v) && v == Math.floor(v);
}

/**
 * 単純型であるか
 * @param {Value} v
 * @returns {boolean} vが単純型であるか
 */
function isPrimitive(v) {
	if (v instanceof IntValue || v instanceof FloatValue || v instanceof StringValue || v instanceof BooleanValue || v instanceof NullValue) return true;
	else return false;
}

/**
 * クラス名を返す
 * @param {Object} obj
 * @return {string} クラス名
 */
function constructor_name(obj) {
	// var result = /^(class|function)\s+([\w\d]+)/.exec(obj.constructor.toString());
	// return result ? result[2] : null;
	if (obj) return obj.constructor.name;
}

/**
 * 全角英数を半角にする
 * @param {string} s
 * @returns {string}
 * @throws {RuntimeError}
 */
function toHalf(s, loc) {
	s = s.toString();
	if (setting.zenkaku_mode == 1 && /[Ａ-Ｚａ-ｚ０-９．−]/.exec(s))
		throw new RuntimeError(loc.first_line, "数値や変数名を全角文字で入力してはいけません");
	return s.replace(/[Ａ-Ｚａ-ｚ０-９．−]/g, function (s) {
		return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
	}
	);
}

/**
 * プログラムコードに改変が加えられたことを示すフラグの操作
 * @param {boolean} b
 */
function makeDirty(b) {
	if (b !== dirty) {
		dirty = b;
		document.getElementById("dirty").style.visibility = dirty ? "visible" : "hidden";
	}
}

/**
 * プログラムにおける位置を表す
 */
class Location {
	/**
	 * @constructor
	 * @param {Token} first_token
	 * @param {Token} last_token
	 */
	constructor(first_token, last_token) {
		this.first_line = first_token.first_line;
		this.last_line = last_token.last_line;
	}
}

/**
 * 実行時エラー
 */
class RuntimeError {
	/**
	 * @constructor
	 * @param {number} line
	 * @param {string} message
	 */
	constructor(line, message) {
		if (selected_quiz < 0) dump('*** 実行時エラー ***');
		this._line = line;
		this._message = message;
		run_flag = false
	}
	get line() { return this._line; }
	get message() { return this._message; }
}

/**
 * 値クラスの親クラス
 */
class Value {
	/**
	 * @constructor
	 * @param {number|string|boolean} v
	 * @param {Location} loc
	 */
	constructor(v, loc) {
		this.value = v;	// value must be value(include array, hash), not Value
		this.loc = loc;
	}
	clone() {
		throw new RuntimeError(this.first_line, constructor_name(this) + "はcloneが作られていません");
	}
	/**
	 * @returns 生のJavaScriptにおける値
	 */
	get first_line() { return this.loc.first_line; }
	/**
	 * @returns {Value} 値がほしいときはこれを使う（Variableなど）。そうでないときはValue本体を使う。
	 */
	getValue() {
		return this;
	}
	/**
	 * @returns {string} PyPENの文法で表した文字列
	 */
	getCode() {
		return '' + this.value;
	}
	/**
	 * @returns {string} Pythonの文法で表した文字列
	 */
	makePython() {
		return this.getCode();
	}
	run() {
		code[0].stack[0].index++;
	}
}

/**
 * 型の決まってない値
 * @extends Value
 */
class NullValue extends Value {
	/**
	 * @constructor
	 * @param {Location} loc
	 */
	constructor(loc) {
		super(null, loc);
	}
	clone() {
		return new NullValue(this.loc);
	}
	makePython() {
		return '';
	}
}

/**
 * vtにあるvn[args]にnewvalをセットする
 * @param {VarTable} vt
 * @param {String} vn
 * @param {Array<Value>} args
 * @param {Value} newval
 * @param {Location} loc
 */
function setVariableByArgs(vt, vn, args, newval, loc) {
	if (args) {
		var v = vt.vars[vn];
		for (var i = 0; i < args.length - 1; i++) {
			var arg = args[i].getValue();
			if (arg instanceof IntValue) {
				if (v instanceof ArrayValue || v instanceof StringValue) {
					var idx = arg.getValue().value;
					var l = v.getValue().length;
					if (idx < 0) idx += l;
					if (idx >= 0 && idx < l) v = v.getValue().value[idx];
					else throw new RuntimeError(loc.first_line, "配列の範囲を超えて代入しようとしました");
				}
				else if (v instanceof StringValue)
					throw new RuntimeError(loc.first_line, "部分文字列の部分文字列への代入はできません");
				else throw new RuntimeError(loc.first_line, "整数の添字は配列か文字列でないと使えません");
			}
			else if (arg instanceof StringValue) {
				var key0 = arg.getValue().value;
				if (v instanceof DictionaryValue) {
					for (var key in v.getValue().value) {
						if (key == key0) {
							v = v.getValue().value[key0];
							key0 = null;
							break;
						}
					}
					if (key0) throw new RuntimeError(loc.first_line, "辞書にキー" + arg.getValue().value + "がありません");
				}
				else throw new RuntimeError(loc.first_line, "文字列の添字は辞書でないと使えません");
			}
			else if (arg instanceof SliceValue)
				throw new RuntimeError(loc.first_line, "スライスの使い方が正しくありません");
			else throw new RuntimeError(loc.first_line, "添字が正しくありません");
		}
		//代入
		var arg = args[args.length - 1].getValue();
		if (arg instanceof IntValue) {
			var idx = arg.value;
			var l = v.getValue().value.length;
			if (idx < 0) idx += l;
			if (idx < 0 || idx >= l) throw new RuntimeError(loc.first_line, "配列の範囲を超えて代入しようとしました");
			if (v.getValue() instanceof ArrayValue) v.value[idx] = newval;
			else if (v.getValue() instanceof StringValue) {
				if (!(newval.getValue() instanceof StringValue)) throw new RuntimeError(loc.first_line, "文字列の途中に文字列でないものを挿入しようとしました");
				var str = v.getValue().value;
				v.getValue().value = str.substr(0, idx) + newval.value + str.substr(idx + 1);
			}
			else throw new RuntimeError(loc.first_line, "整数の添字は配列か文字列にしか使えません");
		}
		else if (arg instanceof StringValue) {
			if (v.getValue() instanceof DictionaryValue) v.getValue().value[arg.value] = newval.clone();
			else throw new RuntimeError(loc.first_line, "文字列の添字は辞書にしか使えません");
		}
		else if (arg instanceof SliceValue) {
			var idx1 = arg.getValue1().getValue().value;
			var idx2 = arg.getValue2().getValue().value;
			if (v.getValue() instanceof ArrayValue) {
				if (!(newval instanceof ArrayValue)) throw new RuntimeError(loc.first_line, "配列に配列でないものを挿入しようとしました");
				var l = v.getValue().length;
				if (!idx1) idx1 = 0;
				if (!idx2) idx2 = l;
				if (idx1 < 0) idx1 += l;
				if (idx2 < 0) idx2 += l;
				if (idx1 >= 0 && idx2 >= 0 && idx1 < l && idx2 < l) {
					var a = [];
					for (var i = 0; i < idx1; i++) a.push(v.getValue().value[i].clone());
					for (var i = 0; i < newval.getValue().length; i++) a.push(newval.getValue().value[i].clone());
					for (var i = idx2; i < l; i++) a.push(v.getValue().value[i].clone());
					v.getValue().value = a;
				}
				else throw new RuntimeError(loc.first_line, "配列の範囲外に挿入しようとしました");
			}
			else if (v.getValue() instanceof StringValue) {
				if (!(newval.getValue() instanceof StringValue)) throw new RuntimeError(loc.first_line, "文字列の途中に文字列でないものを挿入しようとしました");
				var l = v.getValue().length;
				if (!idx1) idx1 = 0;
				if (!idx2) idx2 = l;
				if (idx1 < 0) idx1 += l;
				if (idx2 < 0) idx2 += l;
				if (idx1 >= 0 && idx2 >= 0 && idx1 < l && idx2 < l) {
					var str = v.getValue().value.substr(0, idx1) + newval.getValue().value + v.getValue().value.substr(idx2);
					v.getValue().value = str;
				}
			}
			else throw new RuntimeError("スライスの添字は配列か文字列でないと使えません");
		}
		else throw new RuntimeError(loc.first_line, "添字が正しくありません");
	}
	else {
		vt.vars[vn] = newval;
		return;
	}
}

/**
 * v[args]の値を取得する
 * @param {Variable} v
 * @param {Array<Value>} args
 * @param {Location} loc
 * @returns Value
 */
function getValueByArgs(v, args, loc) {
	if (args) {
		for (var i = 0; i < args.length; i++) {
			var arg = args[i].getValue();
			var val = v.getValue();
			if (arg instanceof IntValue) {
				if (val instanceof ArrayValue)	// 配列のidx番目
				{
					var idx = arg.value;
					var l = val.length;
					if (idx < 0) idx += l;
					if (idx >= 0 && idx < l) v = val.value[idx];
					else throw new RuntimeError(loc.first_line, "配列の範囲を超えてアクセスしました");
				}
				else if (v instanceof StringValue)	// 文字列のidx文字目
				{
					var idx = arg.value;
					var l = val.length;
					if (idx < 0) idx += l;
					if (idx >= 0 && idx < l) v = new StringValue(val.value[idx], loc);
					else throw new RuntimeError(loc.first_line, "文字列の範囲を超えてアクセスしました");
				}
				else throw new RuntimeError(loc.first_line, "整数の添字は配列か文字列でないと使えません");
			}
			else if (arg instanceof StringValue) {
				if (val instanceof DictionaryValue) v = val.value[arg.getValue().value];
				else throw new RuntimeError(loc.first_line, "文字列の添字は辞書でないと使えません");
			}
			else if (arg instanceof SliceValue) {
				var idx1 = arg.getValue1().getValue().value;
				var idx2 = arg.getValue2().getValue().value;
				if (val instanceof ArrayValue)	// 配列のスライス
				{
					var l = val.length;
					if (!idx1) idx1 = 0;
					if (!idx2) idx2 = l;
					if (idx1 < 0) idx1 += l;
					if (idx2 < 0) idx2 += l;
					if (idx1 >= 0 && idx2 >= 0 && idx1 <= l && idx2 <= l) {
						var a = [];
						for (var j = idx1; j < idx2; j++) a.push(val.value[j].clone());
						v = new ArrayValue(a, loc);
					}
					else throw new RuntimeError(loc.first_line, "配列の範囲を超えて読み出そうとしました");
				}
				else if (val instanceof StringValue)	// 文字列のスライス
				{
					var l = val.length;
					if (!idx1) idx1 = 0;
					if (!idx2) idx2 = l;
					if (idx1 < 0) idx1 += l;
					if (idx2 < 0) idx2 += l;
					if (idx1 >= 0 && idx2 >= 0 && idx1 <= l && idx2 <= l) v = new StringValue(val.value.substr(idx1, idx2 - idx1), loc);
					else throw new RuntimeError(loc.first_line, "文字列の範囲を超えて読み出そうとしました");
				}
				else throw new RuntimeError(loc.first_line, "スライスの添字は配列か文字列でないと使えません");
			}
			else throw new RuntimeError(loc.first_line, "添字が正しくありません");
		}
	}
	return v;
}

/**
 * 配列
 */
class ArrayValue extends Value {
	/**
	 * @constructor
	 * @param {Array<Value>} v
	 * @param {Location} loc
	 */
	constructor(v, loc) {
		super(v, loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		var a = [];
		for (var i = 0; i < this.value.length; i++) a.push(this.value[i].getValue());
		return new ArrayValue(a, this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			var a = [];
			for (var i = 0; i < this.value.length; i++) {
				a.push(this.value[i].getValue());
			}
			this.rtnv = new ArrayValue(a, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		var ag = [];
		for (var i = 0; i < this.value.length; i++) ag.push(this.value[i].getCode());
		return '[' + ag.join(',') + ']';
	}
	makePython() {
		var ag = [];
		for (var i = 0; i < this.value.length; i++) ag.push(this.value[i].makePython());
		return '[' + ag.join(', ') + ']';
	}
	get length() { return this.value.length; }
	append(a) {
		for (var i of a) this.value.push(i);
	}
	getValue() {
		return this.rtnv ? this.rtnv : this;
	}
}

/**
 * 辞書
 */
class DictionaryValue extends Value {
	/**
	 * @constructor
	 * @param {Array<SliceValue>} v
	 * @param {Location} loc
	 */
	constructor(v, loc) {
		super(new Map(), loc);
		for (var i = 0; i < v.length; i++) {
			if (v[i] instanceof SliceValue && v[i].getValue1().getValue() instanceof StringValue && !(v[i].getValue2().getValue() instanceof NullValue))
				this.value.set(v[i].getValue1().getValue().value, v[i].getValue2());
			else throw new RuntimeError(loc.first_line, "辞書の初期化が間違っています");
		}
		this.rtnv = this.value;
		this.state = 0;
	}
	clone() {
		var rtnv = new DictionaryValue([], this.loc);
		for (var key of Object.keys(this.value)) {
			if (this.value[key]) {
				rtnv.value[key] = isPrimitive(this.value[key]) ? this.value[key].getValue().clone() : this.value[key].getValue();
			}
			else throw new RuntimeError(this.first_line, key + "が定義されていません");
		}
		return rtnv;
	}
	getCode() {
		var ag = [];
		var keys = Object.keys(this.value);
		keys.sort();
		for (var i = 0; i < keys.length; i++)
			ag.push(keys[i] + ':' + this.value[keys[i]].getCode());
		return '{' + ag.join(',') + '}';
	}
	makePython() {
		var ag = [];
		var keys = Object.keys(this.value);
		keys.sort();
		for (var i = 0; i < keys.length; i++)
			ag.push("'" + keys[i] + "':" + this.value[keys[i]].makePython());
		return '{' + ag.join(', ') + '}';
	}
	run() {
		if (this.state == 0) {
			var a = [];
			for (let key of Object.keys(this.value)) {
				a.push(this.value[key]);
			}
			code[0].stack.unshift({ statementlist: a, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			var a = [];
			for (let key of Object.keys(this.value)) {
				a.push(new SliceValue(new StringValue(key, this.loc), this.value[key], this.loc));
			}
			this.rtnv = new DictionaryValue(a, this.loc);
			this.state = 0;
		}
	}
	getValue() {
		return this.rtnv;
	}
}

class IntValue extends Value {
	constructor(v, loc) {
		super(v, loc);
		if (!isSafeInteger(v)) throw new RuntimeError(this.first_line, "整数で表せない値です");
	}
	clone() {
		return new IntValue(this.value, this.loc);
	}
}
class FloatValue extends Value {
	constructor(v, loc) {
		super(v, loc);
		if (!isFinite(v)) throw new RuntimeError(this.first_line, "オーバーフローしました");
	}
	clone() {
		return new FloatValue(this.value, this.loc);
	}
	getCode() {
		let str = this.value.toString();
		if (str.match(/[Ee]/) != undefined) return str;
		else if (isSafeInteger(this.value)) return this.value + '.0';
		else return this.value;
	}
}

class StringValue extends Value {
	constructor(v, loc) {
		super(v, loc);
	}
	clone() {
		return new StringValue(this.value, this.loc);
	}
	getCode() {
		return '"' + this.value.replace(/"/g, '\\"') + '"';
	}
	get length() { return this.value.length; }
	makePython() {
		return '\'' + this.value.replace('\'', '\\\'') + '\'';
	}
}
class BooleanValue extends Value {
	constructor(v, loc) {
		super(v ? true : false, loc);
	}
	clone() {
		return BooleanValue(this.value, this.loc);
	}
	getCode() {
		return this.value ? 'True' : 'False';
	}
	makePython() {
		return this.value ? "True" : "False";
	}
}

class UNDEFINED extends Value {
	constructor(v, loc) {
		super(v, loc);
	}
	clone() {
		return new UNDEFINED(this.value, this.loc);
	}
	get varname() {
		return this.value;
	}
	getValue() {
		throw new RuntimeError(this.first_line, "未完成のプログラムです");
	}
}

/**
 * 値渡しをする
 */
class Copy extends Value {
	constructor(v, loc) {
		super(v, loc);
		this.state = 0;
	}
	clone() {
		return new Copy(this.value, this.loc);
	}
	getCode() {
		return "copy(" + this.value.getCode() + ")";
	}
	makePython() {
		return this.value.makePython() + ".copy()";
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: [this.value], index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			this.rtnv = this.value.getValue().clone();
			this.state = 0;
		}
	}
	getValue() {
		return this.rtnv;
	}
}
class Pow extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new Pow(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof IntValue && v2 instanceof IntValue && v2.value >= 0) // 整数の自然数乗
			{
				if (v1.value == 0 && v2.value <= 0) throw new RuntimeError(this.first_line, "0は正の数乗しかできません");
				let v = Math.pow(v1.value, v2.value);
				if (isSafeInteger(v)) this.rtnv = new IntValue(v, this.loc);
				else throw new RuntimeError(this.first_line, "整数で表せる範囲を越えました");
			}
			else if ((v1 instanceof IntValue || v1 instanceof FloatValue) && (v2 instanceof IntValue || v2 instanceof FloatValue)) {
				if (v1.value < 0 && !Number.isSafeInteger(v2.value)) throw new RuntimeError(this.first_line, "負の数の非整数乗はできません");
				if (v1.value == 0 && v2.value <= 0) throw new RuntimeError(this.first_line, "0は正の数乗しかできません");
				let v = Math.pow(v1.value, v2.value);
				if (isFinite(v)) this.rtnv = new FloatValue(v, this.loc);
				else throw new RuntimeError(this.first_line, "オーバーフローしました");
			} else throw new RuntimeError('数値でないもののべき乗はできません');
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub" || c1 == "Mul" || c1 == "Div" || c1 == "DivInt" || c1 == "Mod") brace1 = true;
		if (c2 == "Minus" || c2 == "Add" || c2 == "Sub" || c2 == "Mul" || c2 == "Div" || c2 == "DivInt" || c2 == "Mod") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '**'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub" || c1 == "Mul" || c1 == "Div" || c1 == "DivInt" || c1 == "Mod") brace1 = true;
		if (c2 == "Minus" || c2 == "Add" || c2 == "Sub" || c2 == "Mul" || c2 == "Div" || c2 == "DivInt" || c2 == "Mod") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' ** '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class Add extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new Add(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue && v2 instanceof ArrayValue) {
				let v = []
				for (let i = 0; i < v1.length; i++) v.push(v1.value[i])
				for (let i = 0; i < v2.length; i++) v.push(v2.value[i])
				this.rtnv = new ArrayValue(v, this.loc);
			}
			else if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列の足し算はできません");
			else if (v1 instanceof BooleanValue || v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽型の足し算はできません");
			else if (v1 instanceof StringValue || v2 instanceof StringValue) // 一方でも文字列なら文字列結合
			{
				this.rtnv = new StringValue(v1.value + v2.value, this.loc);
			}
			else	// 数値どうし
			{
				let v = v1.value + v2.value;
				if (v1 instanceof FloatValue || v2 instanceof FloatValue)	// 一方が実数型なら結果は実数型
				{
					if (!isFinite(v)) throw new RuntimeError(this.first_line, "オーバーフローしました");
					this.rtnv = new FloatValue(v, this.loc);
				}
				else	// 整数型
				{
					if (!isSafeInteger(v)) throw new RuntimeError(this.first_line, "整数で表される範囲を越えました");
					this.rtnv = new IntValue(v, this.loc);
				}
			}
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus") brace1 = true;
		if (c2 == "Minus") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '+'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus") brace1 = true;
		if (c2 == "Minus") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' + '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class Sub extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new Sub(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列の引き算はできません");
			if (v1 instanceof BooleanValue || v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽型の引き算はできません");
			if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列の引き算はできません");
			let v = v1.value - v2.value;
			if (v1 instanceof FloatValue || v2 instanceof FloatValue) {
				if (!isFinite(v)) throw new RuntimeError(this.first_line, "オーバーフローしました");
				this.rtnv = new FloatValue(v, this.loc);
			}
			else {
				if (!isSafeInteger(v)) throw new RuntimeError(this.first_line, "整数で表される範囲を越えました");
				this.rtnv = new IntValue(v, this.loc);
			}
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus") brace1 = true;
		if (c2 == "Minus") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '-'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus") brace1 = true;
		if (c2 == "Minus") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' - '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class Mul extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.state = 0;
	}
	clone() {
		return new Mul(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof BooleanValue || v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽型のかけ算はできません");
			else if (v1 instanceof StringValue || v2 instanceof StringValue) {
				let va = null, vn = null;
				if (v1 instanceof IntValue) { va = v2; vn = v1; }
				else if (v2 instanceof IntValue) { va = v1; vn = v2; }
				else throw new RuntimeError(this.first_line, "文字列には整数しか掛けられません");
				let v = '';
				for (let i = 0; i < vn.value; i++)
					v += va.value;
				this.rtnv = new StringValue(v, this.loc);
			}
			else if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) {
				let va = null, vn = null;
				if (v1 instanceof IntValue) { va = v2; vn = v1; }
				else if (v2 instanceof IntValue) { va = v1; vn = v2; }
				else throw new RuntimeError(this.first_line, "配列には整数しか掛けられません");
				let v = []
				for (let i = 0; i < vn.value; i++)
					for (let j = 0; j < va.length; j++) v.push(va.value[j]);
				this.rtnv = new ArrayValue(v, this.loc);
			}
			else {
				let v = v1.value * v2.value;
				if (v1 instanceof FloatValue || v2 instanceof FloatValue) {
					if (!isFinite(v)) throw new RuntimeError(this.first_line, "オーバーフローしました");
					this.rtnv = new FloatValue(v, this.loc);
				}
				else {
					if (!isSafeInteger(v)) throw new RuntimeError(this.first_line, "整数で表される範囲を越えました");
					this.rtnv = new IntValue(v, this.loc);
				}
			}
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub") brace1 = true;
		if (c2 == "Minus" || c2 == "Add" || c2 == "Sub") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '*'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub") brace1 = true;
		if (c2 == "Minus" || c2 == "Add" || c2 == "Sub") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' * '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class Div extends Value	// /
{
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new Div(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のわり算はできません");
			if (v1 instanceof BooleanValue || v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽型のわり算はできません");
			if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のわり算はできません");
			if (v2.value == 0) throw new RuntimeError(this.first_line, "0でわり算をしました");
			let v = v1.value / v2.value;
			if (!isFinite(v)) throw new RuntimeError(this.first_line, "オーバーフローしました");
			this.rtnv = new FloatValue(v, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub") brace1 = true;
		if (c2 == "Minus" || c2 == "Add" || c2 == "Sub") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '/'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub") brace1 = true;
		if (c2 == "Minus" || c2 == "Add" || c2 == "Sub") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' / '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class DivInt extends Value // //
{
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new DivInt(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のわり算はできません");
			if (v1 instanceof BooleanValue || v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽型のわり算はできません");
			if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のわり算はできません");
			if (v2.value == 0) throw new RuntimeError(this.first_line, "0でわり算をしました");
			let v = Math.floor(v1.value / v2.value);
			if (!isSafeInteger(v)) throw new RuntimeError(this.first_line, "整数で表される範囲を越えました");
			this.rtnv = new IntValue(v, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub") brace1 = true;
		if (c2 == "Minus" || c2 == "Add" || c2 == "Sub") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '//'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub") brace1 = true;
		if (c2 == "Minus" || c2 == "Add" || c2 == "Sub") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' // '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}


class Mod extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new Mod(this.value[0].clone(), this.value[1].clone(), this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof IntValue && v2 instanceof IntValue) {
				if (v2.value == 0) throw new RuntimeError(this.first_line, "0でわり算をしました");
				let v = v1.value - Math.floor(v1.value / v2.value) * v2.value;
				if (!isSafeInteger(v)) throw new RuntimeError(this.first_line, "整数で表される範囲を越えました");
				this.rtnv = new IntValue(v, this.loc);
			}
			else
				throw new RuntimeError(this.first_line, "余りを出す計算は整数でしかできません");
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub") brace1 = true;
		if (c2 == "Minus" || c2 == "Add" || c2 == "Sub") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '%'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub") brace1 = true;
		if (c2 == "Minus" || c2 == "Add" || c2 == "Sub") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' % '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class Minus extends Value {
	constructor(x, loc) {
		super([x], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new Minus(this.value[0], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue();
			if (v1 instanceof IntValue || v1 instanceof FloatValue) {
				let v = -v1.value;
				if (v1 instanceof IntValue && !isSafeInteger(v)) throw new RuntimeError(this.first_line, "整数で表される範囲を越えました");
				if (v1 instanceof FloatValue && !isFinite(v)) throw new RuntimeError(this.first_line, "オーバーフローしました");
				this.rtnv = v1 instanceof IntValue ? new IntValue(v, this.loc) : new FloatValue(v, this.loc);
			}
			else
				throw new RuntimeError(this.first_line, "マイナスは数値にしかつけられません");
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0];
		let c1 = constructor_name(v1);
		let brace1 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub") brace1 = true;
		return '-' + (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '');
	}
	makePython() {
		let v1 = this.value[0];
		let c1 = constructor_name(v1);
		let brace1 = false;
		if (c1 == "Minus" || c1 == "Add" || c1 == "Sub") brace1 = true;
		return '-' + (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '');
	}
	getValue() {
		return this.rtnv;
	}
}

class And extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new And(this.value[0].clone(), this.value[1].clone(), this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue();
			if (v1 instanceof BooleanValue) {
				if (!v1.value) this.rtnv = new BooleanValue(false, this.loc);
				else {
					let v2 = this.value[1].getValue();
					if (v2 instanceof BooleanValue) this.rtnv = new BooleanValue(v2.value, this.loc);
				}
			}
			else
				throw new RuntimeError(this.first_line, "「かつ」は真偽値にしか使えません");
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c2 == "And" || c2 == "Or" || c2 == "Not") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ ' and '
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c2 == "And" || c2 == "Or" || c2 == "Not") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' and '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class Or extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new Or(this.value[0].clone(), this.value[1].clone(), this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue();
			if (v1 instanceof BooleanValue) {
				if (v1.value) this.rtnv = new BooleanValue(true, this.loc);
				else {
					let v2 = this.value[1].getValue();
					if (v2 instanceof BooleanValue) this.rtnv = new BooleanValue(v2.value, this.loc);
				}
			}
			else
				throw new RuntimeError(this.first_line, "「または」は真偽値にしか使えません");
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c2 == "And" || c2 == "Or" || c2 == "Not") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ ' or '
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c2 == "And" || c2 == "Or" || c2 == "Not") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' or '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class Not extends Value {
	constructor(x, loc) {
		super([x], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new Not(this.value[0], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue();
			if (v1 instanceof BooleanValue) this.rtnv = new BooleanValue(!v1.value, this.loc);
			else throw new RuntimeError(this.first_line, "「でない」は真偽値にしか使えません");
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0];
		let c1 = constructor_name(v1);
		let brace1 = false;
		//	if(c2 == "And" || c2 == "Or" || c2 == "Not") brace2 = true;
		return 'not ' + (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '');
	}
	makePython() {
		let v1 = this.value[0];
		let c1 = constructor_name(v1);
		let brace1 = false;
		if (c1 == "And" || c1 == "Or" || c1 == "Not") brace2 = true;
		return 'not ' + (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '');
	}
	getValue() {
		return this.rtnv;
	}
}

class BitAnd extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new BitAnd(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のビット積はできません");
			else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のビット積はできません");
			else if (v1 instanceof BooleanValue && v2 instanceof BooleanValue) this.rtnv = new BooleanValue(v1.value & v2.value, this.loc);
			else if (v1 instanceof FloatValue || v2 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数のビット積はできません");
			else {
				if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
				if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
				this.rtnv = new IntValue(v1.value & v2.value, this.loc);
			}
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "BitRShift" || c1 == "BitLShift") brace1 = true;
		if (c2 == "Minus" || c2 == "BitRShift" || c2 == "BitLShift") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '&'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "BitRShift" || c1 == "BitLShift" || c1 == "BitNot") brace1 = true;
		if (c2 == "Minus" || c2 == "BitRShift" || c2 == "BitLShift" || c2 == "BitNot") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' & '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class BitOr extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new BitOr(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のビット和はできません");
			else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のビット和はできません");
			else if (v1 instanceof BooleanValue && v2 instanceof BooleanValue) this.rtnv = new BooleanValue(v1.value & v2.value, this.loc);
			else if (v1 instanceof FloatValue || v2 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数のビット和はできません");
			else {
				if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
				if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
				this.rtnv = new IntValue(v1.value | v2.value, this.loc);
			}
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "BitRShift" || c1 == "BitLShift" || c1 == "BitNot") brace1 = true;
		if (c2 == "Minus" || c2 == "BitRShift" || c2 == "BitLShift" || c2 == "BitNot") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '|'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "BitRShift" || c1 == "BitLShift" || c1 == "BitNot") brace1 = true;
		if (c2 == "Minus" || c2 == "BitRShift" || c2 == "BitLShift" || c2 == "BitNot") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' | '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class BitXor extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new BitXor(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列の排他的ビット和はできません");
			else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列の排他的ビット和はできません");
			else if (v1 instanceof BooleanValue && v2 instanceof BooleanValue) this.rtnv = new BooleanValue(v1.value & v2.value, this.loc);
			else if (v1 instanceof FloatValue || v2 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数の排他的ビット和はできません");
			else {
				if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
				if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
				this.rtnv = new IntValue(v1.value ^ v2.value, this.loc);
			}
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "BitRShift" || c1 == "BitLShift" || c1 == "BitNot") brace1 = true;
		if (c2 == "Minus" || c2 == "BitRShift" || c2 == "BitLShift" || c2 == "BitNot") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '^'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "BitRShift" || c1 == "BitLShift" || c1 == "BitNot") brace1 = true;
		if (c2 == "Minus" || c2 == "BitRShift" || c2 == "BitLShift" || c2 == "BitNot") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' ^ '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class BitNot extends Value {
	constructor(x, loc) {
		super([x], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new BitNot(this.value[0], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue()
			if (v1 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のビット反転はできません");
			else if (v1 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のビット反転はできません");
			else if (v1 instanceof BooleanValue) this.rtnv = new BooleanValue(!v1.value, this.loc);
			else if (v1 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数のビット反転はできません");
			else {
				this.rtnv = new IntValue(~v1.value, this.loc);
			}
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0];
		let c1 = constructor_name(v1);
		let brace1 = false;
		if (c1 == "Minus" || c1 == "BitRShift" || c1 == "BitLShift") brace1 = true;
		return '~' + (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '');
	}
	makePython() {
		let v1 = this.value[0];
		let c1 = constructor_name(v1);
		let brace1 = false;
		if (c1 == "Minus" || c1 == "BitRShift" || c1 == "BitLShift") brace1 = true;
		return '~' + (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '');
	}
	getValue() {
		return this.rtnv;
	}
}

class BitLShift extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new BitLShift(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のビットシフトはできません");
			else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のビットシフトはできません");
			else if (v1 instanceof FloatValue || v2 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数のビットシフトはできません");
			else {
				if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
				if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
				this.rtnv = new IntValue(v1.value << v2.value, this.loc);
			}
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "BitNot") brace1 = true;
		if (c2 == "Minus" || c2 == "BitNot") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '<<'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "BitNot") brace1 = true;
		if (c2 == "Minus" || c2 == "BitNot") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' << '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class BitRShift extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new BitRShift(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].state[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のビットシフトはできません");
			else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のビットシフトはできません");
			else if (v1 instanceof FloatValue || v2 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数のビットシフトはできません");
			else {
				if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
				if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
				this.rtnv = new IntValue(v1.value >> v2.value, this.loc);
			}
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "BitNot") brace1 = true;
		if (c2 == "Minus" || c2 == "BitNot") brace2 = true;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '>>'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let c1 = constructor_name(v1), c2 = constructor_name(v2);
		let brace1 = false, brace2 = false;
		if (c1 == "Minus" || c1 == "BitNot") brace1 = true;
		if (c2 == "Minus" || c2 == "BitNot") brace2 = true;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' >> '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}


/**
 * @returns boolean
 * @param {ArrayValue} v1
 * @param {ArrayValue} v2
 */
function ArrayCompare(v1, v2) {
	var rtnv = true;
	if (v1 instanceof ArrayValue && v2 instanceof ArrayValue) {
		if (v1.length != v2.length) return false;
		for (let i = 0; i < v1.length; i++) rtnv = rtnv && ArrayCompare(v1.getValue().value[i], v2.getValue().value[i]);
	}
	else rtnv = rtnv && typeof v1 == typeof v2 && v1.value == v2.value;
	return rtnv;
}

class Compare extends Value {
	constructor(x, y, z, loc) {
		super([x, y, z], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new Compare(this.value[0], this.value[1], this.value[2], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: [this.value[0]], index: 0 });
			this.state = 1;
		}
		else if (this.state == 1) {
			if (this.value[0] instanceof Compare && !this.value[0].getValue().value) {
				code[0].stack[0].index++;
				this.state = 0;
				this.rtnv = new BooleanValue(false, this.loc);
			}
			else {
				code[0].stack.unshift({ statementlist: [this.value[2]], index: 0 });
				this.state = 2;
			}
		}
		else {
			code[0].stack[0].index++;
			this.state = 0;
			var v1, v2 = this.value[2].getValue();
			if (this.value[0] instanceof Compare) v1 = this.value[0].value[2].getValue();
			else v1 = this.value[0].getValue();
			switch (this.value[1]) {
				case '==':
				case '=':
					if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) this.rtnv = new BooleanValue(ArrayCompare(v1, v2), this.loc);
					else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
					else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
					else this.rtnv = new BooleanValue(v1.value == v2.value, this.loc);
					break;
				case '!=':
					if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) this.rtnv = new BooleanValue(!ArrayCompare(v1, v2), this.loc);
					else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
					else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
					else this.rtnv = new BooleanValue(v1.value != v2.value, this.loc);
					break;
				case '>':
					if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列を比べることはできません")
					else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
					else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
					this.rtnv = new BooleanValue(v1.value > v2.value, this.loc);
					break;
				case '<':
					if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列を比べることはできません")
					else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
					else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
					this.rtnv = new BooleanValue(v1.value < v2.value, this.loc);
					break;
				case '>=':
					if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列を比べることはできません")
					else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
					else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
					this.rtnv = new BooleanValue(v1.value >= v2.value, this.loc);
					break;
				case '<=':
					if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列を比べることはできません")
					else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
					else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
					this.rtnv = new BooleanValue(v1.value <= v2.value, this.loc);
					break;
				case 'の中に':
					var flag = false;
					if (v1 instanceof ArrayValue)
						for (let i = 0; i < v1.value.length; i++) flag |= ArrayCompare(v1.value[i], v2);
					else throw new RuntimeError(this.first_line, "\"の中に\"の前には配列が必要です");
					this.rtnv = new BooleanValue(flag, this.loc);
					break;
				case 'in':
					var flag = false;
					if (v2 instanceof ArrayValue)
						for (let i = 0; i < v2.value.length; i++) flag |= ArrayCompare(v2.value[i], v1);
					else throw new RuntimeError(this.first_line, "\"in\"の後には配列が必要です");
					this.rtnv = new BooleanValue(flag, this.loc);
					break;
				case 'not in':
					var flag = false;
					if (v2 instanceof ArrayValue)
						for (let i = 0; i < v2.value.length; i++) flag |= ArrayCompare(v2.value[i], v1);
					else throw new RuntimeError(this.first_line, "\"not in\"の後には配列が必要です");
					this.rtnv = new BooleanValue(!flag, this.loc);
			}
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[2];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ this.value[1]
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[2];
		let brace1 = false, brace2 = false;
		var op = this.value[1];
		switch (this.value[1]) {
			case 'not in':
				op = ' not in ';
				break;
			case 'in':
				op = ' in ';
				break;
			case 'の中に':
				op = ' in ';
				var tmp = v1; v1 = v2; v2 = tmp;
				break;
			case '=':
				op = ' == ';
				break;
			default:
				op = ' ' + op + ' ';
		}
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ op
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class EQ extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new EQ(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) this.rtnv = new BooleanValue(ArrayCompare(v1, v2), this.loc);
			else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
			else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
			else this.rtnv = new BooleanValue(v1.value == v2.value, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '=='
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' == '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class NE extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new NE(this.value[0].clone(), this.value[1].clone(), this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) this.rtnv = new BooleanValue(!ArrayCompare(v1, v2), this.loc);
			else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
			else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
			else this.rtnv = new BooleanValue(v1.value != v2.value, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '!='
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' != '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class GT extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new GT(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列を比べることはできません")
			else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
			else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
			this.rtnv = new BooleanValue(v1.value > v2.value, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '>'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' > '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class GE extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new GE(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列を比べることはできません")
			else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
			else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
			this.rtnv = new BooleanValue(v1.value >= v2.value, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '>='
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' >= '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class LT extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new LT(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列を比べることはできません")
			else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
			else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
			this.rtnv = new BooleanValue(v1.value < v2.value, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '<'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' < '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class LE extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new LE(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列を比べることはできません")
			else if (v1 instanceof StringValue != v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列とそれ以外の値は比べられません");
			else if (v1 instanceof BooleanValue != v2 instanceof BooleanValue) throw new RuntimeError(this.first_line, "真偽値とそれ以外の値は比べられません");
			this.rtnv = new BooleanValue(v1.value <= v2.value, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '<='
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.makePython() + (brace1 ? ')' : '')
			+ ' <= '
			+ (brace2 ? '(' : '') + v2.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class IN extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new IN(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = this.value[0].getValue(), v2 = this.value[1].getValue();
			var flag = false;
			if (v1 instanceof ArrayValue)
				for (let i = 0; i < v1.value.length; i++) flag |= ArrayCompare(v1.value[i], v2);
			else throw new RuntimeError(this.first_line, "\"の中に\"の前には配列が必要です");
			this.rtnv = new BooleanValue(flag, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ 'の中に'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython()	// 逆順になることに注意
	{
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v2.makePython() + (brace1 ? ')' : '')
			+ ' in '
			+ (brace2 ? '(' : '') + v1.makePython() + (brace2 ? ')' : '')
	}
	getValue() {
		return this.rtnv;
	}
}

class NumberOf extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new NumberOf(this.value[0], this.value[1], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let vt = new varTable();
			let statementlist = [];
			let globalvarTable = varTables[varTables.length - 1];
			for (let v of Object.keys(globalvarTable.vars)) vt.vars[v] = globalvarTable.vars[v].getValue().clone();
			for (let v of Object.keys(varTables[0].vars)) vt.vars[v] = varTables[0].vars[v].getValue().clone();
			// 空リストを'!'という変数に代入する。カウンタは'!!'
			let var1 = new Variable('!', null, this.loc);
			let var2 = new Variable('!!', null, this.loc);
			statementlist.push(new Assign(var1, new ArrayValue([], this.loc), null, this.loc));
			statementlist.push(new ForInc(var2, new IntValue(1, this.loc), this.value[0].getValue(), new IntValue(1, this.loc),
				[this.value[1], new Append(var1, this.value[1], this.loc)], this.loc));
			// statementlist.push(new runBeforeGetValue([var1], this.loc));
			statementlist.push(var1);
			statementlist.push(new ReturnStatement(var1, this.loc));

			setCaller(statementlist, this);
			code.unshift(new parsedFunction(statementlist));
			varTables.unshift(vt);
			this.state = 0;
		}
	}
	getCode() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return (brace1 ? '(' : '') + v1.getCode() + (brace1 ? ')' : '')
			+ '個の'
			+ (brace2 ? '(' : '') + v2.getCode() + (brace2 ? ')' : '')
	}
	makePython() {
		let v1 = this.value[0], v2 = this.value[1];
		let brace1 = false, brace2 = false;
		return '[' + (brace1 ? '(' : '') + v2.makePython() + (brace1 ? ')' : '')
			+ ' for _ in range('
			+ (brace2 ? '(' : '') + v1.makePython() + (brace2 ? ')' : '')
			+ ')]';
	}
	getValue() {
		return this.rtnv;
	}
	setValue(v) {
		this.rtnv = v.clone();
	}
}


class ConvertInt extends Value {
	constructor(x, loc) {
		super([x], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new ConvertInt(this.value[0], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v = this.value[0].getValue();
			let r = Number.NaN;
			if (v instanceof IntValue) r = v.value;
			else if (v instanceof FloatValue) r = Math.floor(v.value);
			else if (v instanceof StringValue) r = Math.floor(Number(v.value));
			else if (v instanceof BooleanValue) r = v.value ? 1 : 0;
			if (isSafeInteger(r)) this.rtnv = new IntValue(r, this.loc);
			else throw new RuntimeError(this.loc.first_line, '整数に直せません');
			this.state = 0;
		}
	}
	getCode() {
		return '整数(' + this.value[0].getCode() + ')';
	}
	makePython() {
		return 'int(' + this.value[0].makePython() + ')';
	}
	getValue() {
		return this.rtnv;
	}
}

class ConvertFloat extends Value {
	constructor(x, loc) {
		super([x], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new ConvertFloat(this.value[0], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v = this.value[0].getValue();
			let r = Number.NaN;
			if (v instanceof IntValue || v instanceof FloatValue) r = v.value;
			else if (v instanceof StringValue) r = Number(v.value);
			else if (v instanceof BooleanValue) r = v.value ? 1 : 0;
			if (isFinite(r)) this.rtnv = new FloatValue(r, this.loc);
			else throw new RuntimeError(this.loc.first_line, '実数に直せません');
			this.state = 0;
		}
	}
	getCode() {
		return '実数(' + this.value[0].getCode() + ')';
	}
	makePython() {
		return 'float(' + this.value[0].makePython() + ')';
	}
	getValue() {
		return this.rtnv;
	}
}

class ConvertString extends Value {
	constructor(x, loc) {
		super([x], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return ConvertString(this.value[0], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v = this.value[0].getValue();
			let r = '';
			if (v instanceof IntValue || v instanceof FloatValue) r = String(v.value);
			else if (v instanceof StringValue) r = v.value
			else if (v instanceof BooleanValue) r = v.value ? 'True' : 'False';
			this.rtnv = new StringValue(r, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		return '文字列(' + this.value[0].getCode() + ')';
	}
	makePython() {
		return 'str(' + this.value[0].makePython() + ')';
	}
	getValue() {
		return this.rtnv;
	}
}

class ConvertBool extends Value {
	constructor(x, loc) {
		super([x], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new ConvertBool(this.value[0], this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v = this.value[0].getValue();
			let r = '';
			let re = /^(0+|false|偽|)$/i;
			if (v instanceof IntValue || v instanceof FloatValue) r = v.value != 0;
			else if (v instanceof StringValue) r = re.exec(v.value) ? false : true;
			else if (v instanceof BooleanValue) r = v.value;
			this.rtnv = new BooleanValue(r, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		return '真偽(' + this.value[0].getCode() + ')';
	}
	makePython() {
		return 'bool(' + this.value[0].makePython() + ')';
	}
	getValue() {
		return this.rtnv;
	}
}

class Variable extends Value {
	/**
	 *
	 * @param {string} x
	 * @param {ArrayValue} y
	 * @param {Location} loc
	 */
	constructor(x, y, loc) {
		super([x, y], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		return new Variable(this.value[0], this.value[1] ? this.value[1] : null, this.loc);
	}
	get varname() { return this.value[0]; }
	get args() { return this.value[1]; }
	run() {
		if (this.state == 0) {
			if (this.args) code[0].stack.unshift({ statementlist: this.args.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let vn = this.varname;		// 変数名
			let vt = findVarTable(vn);	// 変数は定義されてるか
			if (vt) {
				let v = vt.vars[vn];
				this.rtnv = getValueByArgs(v, this.args ? this.args.value : null, this.loc);
			}
			else throw new RuntimeError(this.first_line, "変数" + this.varname + "が定義されていません");
			this.state = 0;
		}
	}
	getCode() {
		let vn = this.value[0];
		let pm = this.value[1];
		if (pm != null) {
			let ag = new Array(pm.length);
			for (let i = 0; i < pm.length; i++) {
				ag[i] = pm.value[i].getCode();
			}
			vn += '[' + ag.join(',') + ']';
		}
		return vn;
	}
	makePython() {
		let vn = this.value[0];
		let pm = this.value[1];
		if (pm != null) {
			let ag = new Array(pm.length);
			for (let i = 0; i < pm.length; i++) {
				ag[i] = '[' + pm.value[i].makePython() + ']';
			}
			vn += ag.join('');
		}
		return vn;
	}
	getValue() {
		return this.rtnv;
	}
	append(a) {
		if (this.args) this.args.append(a);
		else this.value[1] = new ArrayValue(a, this.loc);
	}
}


/**
 * 定義済み関数クラス
 */
class DefinedFunction {
	/**
	 * @constructor
	 * @param {number} argc 引数の個数
	 * @param {function} func 実際の関数
	 * @param {string} module Pythonで必要となるモジュール。nullならナニもいらない
	 * @param {function} convert this.argcを受け取ってPythonコードの文字列を返す関数。nullならthis.funcName(this.argc)的なことをする。
	 */
	constructor(argc, func, module, convert) {
		this.argc = argc; this.func = func; this.module = module; this.convert = convert;
		this.caller = null;
		this.loc = null;
	}
	/**
	 * 関数の値を返す
	 * @param {Array<Value>} parameters
	 * @param {Location} loc
	 * @returns {any}
	 */
	run() {
		if ((this.argc instanceof Array && this.argc[0] <= this.parameters.length && this.argc[1] >= this.parameters.length)
			|| this.parameters.length == this.argc) {
			code[0].stack[0].index++;
			this.caller.setValue(this.func(this.parameters, this.loc));
			code.shift();
		}
		else throw new RuntimeError(this.loc.first_line, "引数の個数が違います");
	}
	clone() {
		return new DefinedFunction(this.argc, this.func, this.module, this.convert);
	}
	setCaller(caller) {
		this.caller = caller;
	}
	setParameter(params) {
		this.parameters = params;
	}
	setLocation(loc) {
		this.loc = loc;
	}
}

/**
 * 定義済み関数一覧
 */
var definedFunction = {
	"keys": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof DictionaryValue) {
			var args = [];
			var keys = Object.keys(par1.value);
			keys.sort();
			for (let i = 0; i < keys.length; i++) args.push(new StringValue(keys[i], loc));
			return new ArrayValue(args, this.loc);
		}
		else throw new RuntimeError(loc.first_line, 'keysは辞書にしか使えません');
	}, null, null),
	"abs": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue) return new IntValue(Math.abs(par1.value), loc);
		else if (par1 instanceof FloatValue) return new FloatValue(Math.abs(par1.value), loc);
		else throw new RuntimeError(loc.first_line, "absは数値にしか使えません");
	}, null, null),
	"random": new DefinedFunction([0, 1], function (param, loc) {
		if (param.length == 0) return new FloatValue(Math.random(), this.loc);
		else {
			var par1 = param[0].getValue();
			if (par1 instanceof IntValue) return new IntValue(Math.floor(Math.random() * Math.floor(par1.value + 1)), this.loc);
			else throw new RuntimeError(loc.first_line, "randomは整数にしか使えません");
		}
	}, "random", function (argc) {
		if (argc[0]) return "random.randint(0," + argc[0] + ")";
		else return "random.random()";
	}),
	"ceil": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue) return par1;
		else if (par1 instanceof FloatValue) return new IntValue(Math.ceil(par1.value), this.loc);
		else throw new RuntimeError(loc.first_line, "ceilは数値にしか使えません");
	}, "math", null),
	"floor": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue) return par1;
		else if (par1 instanceof FloatValue) return new IntValue(Math.floor(par1.value), this.loc);
		else throw new RuntimeError(loc.first_line, "floorは数値にしか使えません");
	}, "math", null),
	"round": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue) return par1;
		else if (par1 instanceof FloatValue) return new IntValue(Math.round(par1.value), this.loc);
		else throw new RuntimeError(loc.first_line, "roundは数値にしか使えません");
	}, null, null),
	"sin": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue || par1 instanceof FloatValue)
			return new FloatValue(Math.sin(par1.value), this.loc);
		else throw new RuntimeError(loc.first_line, "sinは数値にしか使えません");
	}, "math", null),
	"cos": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue || par1 instanceof FloatValue)
			return new FloatValue(Math.cos(par1.value), this.loc);
		else throw new RuntimeError(loc.first_line, "cosは数値にしか使えません");
	}, "math", null),
	"tan": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue || par1 instanceof FloatValue) {
			let v = Math.tan(par1.value);
			if (isFinite(v)) return new FloatValue(v, this.loc);
			else throw new RuntimeError(loc.first_line, "オーバーフローしました");
		}
		else throw new RuntimeError(loc.first_line, "tanは数値にしか使えません");
	}, "math", null),
	"asin": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue || par1 instanceof FloatValue) {
			if (par1.value > 1.0 || par1.value < -1.0)
				throw new RuntimeError(loc.first_line, "asinの定義域外の値が使われました");
			else
				return new FloatValue(Math.asin(par1.value), this.loc);
		}
		else throw new RuntimeError(loc.first_line, "asinは数値にしか使えません");
	}, "math", null),
	"acos": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue || par1 instanceof FloatValue) {
			if (par1.value > 1.0 || par1.value < -1.0)
				throw new RuntimeError(loc.first_line, "acosの定義域外の値が使われました");
			else
				return new FloatValue(Math.acos(par1.value), this.loc);
		}
		else throw new RuntimeError(loc.first_line, "acosは数値にしか使えません");
	}, "math", null),
	"atan": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue || par1 instanceof FloatValue)
			return new FloatValue(Math.atan(par1.value), this.loc);
		else throw new RuntimeError(loc.first_line, "atanは数値にしか使えません");
	}, "math", null),
	"atan2": new DefinedFunction(2, function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		if ((par1 instanceof IntValue || par1 instanceof FloatValue) &&
			(par2 instanceof IntValue || par2 instanceof FloatValue))
			return new FloatValue(Math.atan2(par1.value, par2.value), this.loc);
		else throw new RuntimeError(loc.first_line, "atan2は数値にしか使えません");
	}, "math", null),
	"sqrt": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue || par1 instanceof FloatValue) {
			if (par1.value < 0) throw new RuntimeError(loc.first_line, "負の数のルートを求めようとしました");
			return new FloatValue(Math.sqrt(par1.value), this.loc);
		}
		else throw new RuntimeError(this.first_line, "sqrtは数値にしか使えません");
	}, "math", null),
	"log": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue || par1 instanceof FloatValue) {
			if (par1.value <= 0) throw new RuntimeError(loc.first_line, "正でない数の対数を求めようとしました");
			let v = Math.log(par1.value);
			if (isFinite(v)) return new FloatValue(v, this.loc);
			throw new RuntimeError(this.first_line, "オーバーフローしました");
		}
		else throw new RuntimeError(loc.first_line, "logは数値にしか使えません");
	}, "math", null),
	"exp": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue || par1 instanceof FloatValue) {
			let v = Math.exp(par1.value);
			if (isFinite(v)) return new FloatValue(v, this.loc);
			throw new RuntimeError(loc.first_line, "オーバーフローしました");
		}
		else throw new RuntimeError(loc.first_line, "expは数値にしか使えません");
	}, "math", null),
	"pow": new DefinedFunction(2, function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		if (par1 instanceof IntValue && par2 instanceof IntValue && par2.value >= 0) {
			if (par1.value == 0 && par2.value <= 0) throw new RuntimeError(loc.first_line, "0は正の数乗しかできません");
			let v = Math.pow(par1.value, par2.value);
			if (isSafeInteger(v)) return new IntValue(v, this.loc);
			else throw new RuntimeError(loc.first_line, "整数で表せる範囲を越えました");
		}
		else if ((par1 instanceof IntValue || par1 instanceof FloatValue) &&
			(par2 instanceof IntValue || par2 instanceof FloatValue)) {
			if (par1.value < 0 && !Number.isInteger(par2.value)) throw new RuntimeError(loc.first_line, "負の数の非整数乗はできません");
			if (par1.value == 0 && par2.value <= 0) throw new RuntimeError(loc.first_line, "0は正の数乗しかできません");
			let v = Math.pow(par1.value, par2.value);
			if (isFinite(v)) return new FloatValue(v, this.loc);
			else throw new RuntimeError(loc.first_line, "オーバーフローしました");
		}
		else throw new RuntimeError(loc.first_line, "powerは数値にしか使えません");
	}, null, null),
	"length": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof StringValue) return new IntValue(par1.value.length, this.loc);
		else if (par1 instanceof ArrayValue) return new IntValue(par1.length, this.loc);
		else throw new RuntimeError(loc.first_line, "lengthは文字列と配列にしか使えません");
	}, null, function (argc) {
		return "len(" + argc[0] + ")";
	}),
	"substring": new DefinedFunction([2, 3], function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		var par3 = param.length == 3 ? param[2].getValue() : null;
		if (par1 instanceof StringValue &&
			par2 instanceof IntValue &&
			(par3 == null || par3 instanceof IntValue)) {
			var v;
			if (par3 == null) v = par1.value.substr(par2.value);
			else v = par1.value.substr(par2.value, par3.value);
			return new StringValue(v, this.loc);
		}
		else throw new RuntimeError(loc.first_line, "substringの引数の型が違います");
	}, null, function (argc) {
		var code = argc[0] + '[' + argc[1] + ':';
		if (argc[2]) code += argc[1] + '+' + argc[2];
		return code + ']';
	}),
	"append": new DefinedFunction(2, function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		if (par2 instanceof StringValue && par2 instanceof StringValue) {
			return new StringValue(par1.value + par2.value, this.loc);
		}
		else throw new RuntimeError(loc.first_line, "appendの引数の型が違います");
	}, null, function (argc) {
		return argc[0] + '+' + argc[1];
	}),
	"split": new DefinedFunction([1, 2], function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param.length == 2 ? param[1].getValue() : null;
		if (par1 instanceof StringValue && (par2 instanceof StringValue || par2 == null)) {
			var v1 = par1.value;
			var v = par2 ? v1.split(par2.value) : v1.split("");
			var vr = [];
			for (var i = 0; i < v.length; i++) vr.push(new StringValue(v[i], this.loc));
			return new ArrayValue(vr, this.loc);
		}
		else throw new RuntimeError(loc.first_line, "splitの引数の型が違います");
	}, null, function (argc) {
		if (argc.length == 2) return argc[0] + '.split(' + argc[1] + ')';
		else return 'list(' + argc[0] + ')';
	}),
	"extract": new DefinedFunction(3, function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		var par3 = param[2].getValue();
		if (par1 instanceof StringValue && par2 instanceof StringValue && par3 instanceof IntValue) {
			var v1 = par1.value;
			var v2 = par2.value;
			var v3 = par3.value;
			var v = v1.split(v2);
			if (v3 >= 0 && v3 < v.length) return new StringValue(v[v3], this.loc);
			else throw new RuntimeError(loc.first_line, "番号の値が不正です");
		}
		else throw new RuntimeError(loc.first_line, "extractの引数の型が違います");
	}, null, function (argc) {
		return argc[0] + '.split(' + argc[1] + ')[' + argc[2] + ']';
	}),
	"insert": new DefinedFunction(3, function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		var par3 = param[2].getValue();
		if (par1 instanceof StringValue && par2 instanceof IntValue && par3 instanceof StringValue) {
			var v1 = par1.value;
			var v2 = par2.value;
			var v3 = par3.value;
			if (v2 < 0 || v2 > v1.length) throw new RuntimeError(loc.first_line, "位置の値が不正です");
			var s1 = v1.substr(0, v2);
			var s2 = v1.substr(v2);
			return new StringValue(s1 + v3 + s2, this.loc);
		}
		else throw new RuntimeError(loc.first_line, "insertの引数の型が違います");
	}, null, function (argc) {
		return argc[0] + '[:' + argc[1] + ']+' + argc[2] + '+' + argc[0] + '[' + argc[1] + ':]';
	}),
	"replace": new DefinedFunction(4, function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		var par3 = param[2].getValue();
		var par4 = param[3].getValue();
		if (par1 instanceof StringValue && par2 instanceof IntValue && par3 instanceof IntValue && par4 instanceof StringValue) {
			var v1 = par1.value;
			var v2 = par2.value;
			var v3 = par3.value;
			var v4 = par4.value;

			if (v2 < 0 || v2 > v1.length) throw new RuntimeError(loc.first_line, "位置の値が不正です");
			if (v3 < 0 || v2 + v3 > v1.length) throw new RuntimeError(loc.first_line, "長さの値が不正です");
			var s1 = v1.substr(0, v2);
			var s2 = v1.substr(v2 + v3);
			return new StringValue(s1 + v4 + s2, this.loc);
		}
		else throw new RuntimeError(loc.first_line, "replaceの引数の型が違います");
	}, null, function (argc) {
		return argc[0] + '[:' + argc[1] + ']+' + argc[3] + '+' + argc[0] + '[' + argc[1] + '+' + argc[2] + ':]';
	}),
	"isfile": new DefinedFunction(1, function (param, loc) {
		var par = param[0].getValue();
		if (par instanceof StringValue) return new BooleanValue(storage.getItem(par.value) != null, loc);
		else throw new RuntimeError(loc.first_line, "ファイル名は文字列でなくてはいけません");
	}, null, null),
	"openr": new DefinedFunction(1, function (param, loc) {
		var par = param[0].getValue();
		if (par instanceof StringValue) return new IntValue(filesystem.openr(par.value), loc);
		else throw new RuntimeError(loc.first_line, "ファイル名は文字列でなくてはいけません");
	}, null, function (argc) {
		return "open(" + argc[0] + ",'r')";
	}),
	"openw": new DefinedFunction(1, function (param, loc) {
		var par = param[0].getValue();
		if (par instanceof StringValue) return new IntValue(filesystem.openw(par.value), loc);
		else throw new RuntimeError(loc.first_line, "ファイル名は文字列でなくてはいけません");
	}, null, function (argc) {
		return "open(" + argc[0] + ",'w')";
	}),
	"opena": new DefinedFunction(1, function (param, loc) {
		var par = param[0].getValue();
		if (par instanceof StringValue) return new IntValue(filesystem.opena(par.value), loc);
		else throw new RuntimeError(loc.first_line, "ファイル名は文字列でなくてはいけません");
	}, null, function (argc) {
		return "open(" + argc[0] + ",'a')";
	}),
	"getline": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue) {
			var rtnv = filesystem.read_line(par1.value);
			if (rtnv == null) throw new RuntimeError(loc.first_line, "ファイル番号が不正です");
			return new StringValue(rtnv, loc);
		}
		else throw new RuntimeError(loc.first_line, "ファイル番号が必要です");
	}, null, function (argc) {
		return argc[0] + ".readline()";
	}),
	"getchar": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue) {
			var rtnv = filesystem.read_ch(par1.value);
			if (rtnv == null) throw new RuntimeError(loc.first_line, "ファイル番号が不正です");
			return new StringValue(rtnv, loc);
		}
		else throw new RuntimeError(loc.first_line, "ファイル番号が必要です");
	}, null, function (argc) {
		return argc[0] + ".read(1)";
	}),
	"pop": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof ArrayValue) {
			if (par1.value.length > 0)
				return par1.value.pop();
			else throw new RuntimeError(loc.first_line, "空の配列にpopを適用しようとしました");
		}
		else throw new RuntimeError(loc.first_line, "popは配列にしか使えません");
	}, null, function (argc) {
		return argc[0] + '.pop()';
	}),
	"shift": new DefinedFunction(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof ArrayValue) {
			if (par1.value.length > 0)
				return par1.value.shift();
			else throw new RuntimeError(loc.first_line, "空の配列にshiftを適用しようとしました");
		}
		else throw new RuntimeError(loc.first_line, "shiftは配列にしか使えません");
	}, null, function (argc) {
		return argc[0] + '.pop(0)';
	}),
};

function setCaller(statementlist, caller) {
	for (let i = 0; i < statementlist.length; i++) {
		if (statementlist[i].statementlist) setCaller(statementlist[i].statementlist, caller);
		if (statementlist[i].state) setCaller(statementlist[i].state, caller);
		if (statementlist[i].blocks) {
			for (var j = 0; j < statementlist[i].blocks.length; j++)
				setCaller(statementlist[i].blocks[j][1], caller);
		}
		if (statementlist[i] instanceof ReturnStatement) statementlist[i].setCaller(caller, true);
	}
}

function cloneStatementlist(statementlist) {
	var rtnv = [];
	for (let i = 0; i < statementlist.length; i++) if (statementlist[i]) rtnv.push(statementlist[i].clone());
	return rtnv;
}

/**
 * 関数呼び出し
 */
class CallFunction extends Value {
	/**
	 * @constructor
	 * @param {string} funcname
	 * @param {Array<Value>} parameter
	 * @param {Location} loc
	 */
	constructor(funcname, parameter, loc) {
		super([funcname, parameter], loc);
		this.rtnv = null;
		this.state = 0;
	}
	clone() {
		var parm = [];
		for (var i = 0; i < this.value[1].length; i++) parm.push(this.value[1][i]);
		var rtnv = new CallFunction(this.value[0], parm, this.loc);
		rtnv.rtnv = this.rtnv;
		return rtnv;
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value[1], index: 0 });
			this.state = 1;
		}
		else if (this.state == 1) {
			code[0].stack[0].index++;
			const func = this.value[0], param = this.value[1];
			if (definedFunction[func]) {
				let fn = definedFunction[func].clone();
				fn.setCaller(this);
				fn.setParameter(param);
				fn.setLocation(this.loc);
				let statementlist = [fn];
				code.unshift(new parsedFunction(statementlist));
			}
			else if (myFuncs[func]) {
				let fn = myFuncs[func];
				let vt = new varTable();
				let globalVarTable = varTables[varTables.length - 1];
				for (let i of Object.keys(globalVarTable.vars)) vt.vars[i] = globalVarTable.vars[i].getValue();
				for (let i = 0; i < fn.params.length; i++) vt.vars[fn.params[i].varname] = param[i].getValue();
				let statementlist = cloneStatementlist(fn.statementlist);
				setCaller(statementlist, this);
				statementlist.push(new notReturnedFunction(fn.loc));
				let pf = new parsedFunction(statementlist);
				code.unshift(pf);
				varTables.unshift(vt);
			}
			else
				throw new RuntimeError(this.first_line, '関数 ' + func + ' は定義されていません');
			this.state = 0;
		}
	}
	setValue(v) {
		this.rtnv = v.clone();
	}
	getValue() {
		return this.rtnv;
	}
	getCode() {
		let func = this.value[0], param = this.value[1];
		let ag = [];
		for (let i = 0; i < param.length; i++)
			ag.push(param[i].getCode());
		return func + '(' + ag.join(',') + ')';
	}
	makePython() {
		let func = this.value[0], param = this.value[1];
		let deffunc = null;
		if (definedFunction[func]) deffunc = definedFunction[func];
		else if (myFuncs[func]) deffunc = myFuncs[func];
		let ag = [];
		for (let i = 0; i < param.length; i++)
			ag.push(param[i].makePython());
		if (deffunc) {
			var prefix = '';
			if (deffunc.module) {
				prefix = deffunc.module + ".";
				python_lib[deffunc.module] = 1;
			}
			if (deffunc.convert) return deffunc.convert(ag);
			else return prefix + func + '(' + ag.join(', ') + ')';
		}
		else
			return func + '(' + ag.join(', ') + ')';
	}
}

class Connect extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.state = 0;
	}
	clone() {
		var rtnv = new Connect(this.value[0].clone(), this.value[1].clone(), this.loc);
		rtnv.rtnv = this.rtnv;
		return rtnv;
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let v1 = array2text(this.value[0].getValue());
			let v2 = array2text(this.value[1].getValue());
			let v = v1 + v2;
			this.rtnv = new StringValue(v, this.loc);
			this.state = 0;
		}
	}
	getCode() {
		return this.value[0].getCode() + "と" + this.value[1].getCode();
	}
	makePython() {
		var re = /^str\(/;
		var p1 = this.value[0].makePython();
		var p2 = this.value[1].makePython();
		if (!re.exec(p1) && !(this.value[0] instanceof StringValue)) p1 = "str(" + p1 + ")";
		if (!re.exec(p2) && !(this.value[1] instanceof StringValue)) p2 = "str(" + p2 + ")";
		return p1 + " + " + p2;
	}
	getValue() {
		return this.rtnv;
	}
}

class SliceValue extends Value {
	constructor(x, y, loc) {
		super([x, y], loc);
		this.state = 0;
	}
	clone() {
		var rtnv = new SliceValue(this.value[0].clone(), this.value[1].clone(), this.loc);
		rtnv.rtnv = this.rtnv;
		return rtnv;
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			this.state = 0;
		}
	}
	getCode() {
		return this.value[0].getCode() + ":" + this.value[1].getCode();
	}
	makePython() {
		var p1 = this.value[0].makePython();
		var p2 = this.value[1].makePython();
		return p1 + ":" + p2;
	}
	getValue() {
		return this;
	}
	getValue1() {
		return this.value[0];
	}
	getValue2() {
		return this.value[1];
	}
}

/**
 * 定義済み手続きクラス
 */
class DefinedStep {
	/**
	 * @constructor
	 * @param {number} argc 引数の個数
	 * @param {function} step 実際の関数
	 * @param {string} module Pythonで必要となるモジュール。nullならナニもいらない
	 * @param {function} convert this.argcを受け取ってPythonコードの文字列を返す関数。nullならthis.funcName(this.argc)的なことをする。
	 */
	constructor(argc, step, module, convert) {
		this.argc = argc; this.step = step; this.module = module; this.convert = convert;
		this.loc = null;
	}
	/**
	 * 関数の値を返す
	 * @param {Array<Value>} parameters
	 * @param {Location} loc
	 * @returns {any}
	 */
	run() {
		if ((this.argc instanceof Array && this.argc[0] <= this.parameters.length && this.argc[1] >= this.parameters.length)
			|| this.parameters.length == this.argc) {
			code[0].stack[0].index++;
			this.step(this.parameters, this.loc);
			code.shift();
		}
		else throw new RuntimeError(this.loc.first_line, "引数の個数が違います");
	}
	clone() {
		return new DefinedStep(this.argc, this.step, this.module, this.convert);
	}
	setParameter(params) {
		this.parameters = params;
	}
	setLocation(loc) {
		this.loc = loc;
	}
}

/**
 * 定義済み関数一覧
 */
var definedStep = {
	"putline": new DefinedStep(2, function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		if (par1 instanceof IntValue && par2 instanceof StringValue) {
			var str = array2text(par2);
			var rtnv = filesystem.write_str(par1.value, str, true);
			if (!rtnv) throw new RuntimeError(this.first_line, "呼び出しが不正です");
		}
		else throw new RuntimeError(this.first_line, "呼び出しが不正です");
	}, null, function (argc) {
		var str = argc[1].makePython();
		if (!(argc[1] instanceof StringValue))
			str = 'str(' + str + ')';
		return argc[0].makePython() + '.write(' + str + " + '\n')";
	}),
	"putstr": new DefinedStep(2, function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		if (par1 instanceof IntValue && par2 instanceof StringValue) {
			var str = array2text(par2);
			var rtnv = filesystem.write_str(par1.value, str, true);
			if (!rtnv) throw new RuntimeError(this.first_line, "呼び出しが不正です");
		}
		else throw new RuntimeError(this.first_line, "呼び出しが不正です");
	}, null, function (argc) {
		var str = argc[1].makePython();
		if (!(argc[1] instanceof StringValue))
			str = 'str(' + str + ')';
		return argc[0].makePython() + '.write(' + str + " + '\n')";
	}),
	"close": new DefinedStep(1, function (param, loc) {
		var par1 = param[0].getValue();
		if (par1 instanceof IntValue) {
			var rtnv = filesystem.close(par1.value, true);
			if (!rtnv) throw new RuntimeError(this.first_line, "呼び出しが不正です");
		}
		else throw new RuntimeError(this.first_line, "呼び出しが不正です");
	}, null, function (argc) {
		return argc[0].makePython() + '.close()\n';
	}),
	"push": new DefinedStep(2, function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		if (par1 instanceof ArrayValue && par2 instanceof Value) {
			par1.value.push(par2);
		}
		else throw new RuntimeError(loc.first_line, 'pushは配列にしか使えません');
	}, null, function (argc) {
		return argc[0].makePython() + '.append(' + argc[1].makePython() + ')\n';
	}),
	"unshift": new DefinedStep(2, function (param, loc) {
		var par1 = param[0].getValue();
		var par2 = param[1].getValue();
		if (par1 instanceof ArrayValue && par2 instanceof Value) {
			par1.value.unshift(par2);
		}
		else throw new RuntimeError(loc.first_line, 'pushは配列にしか使えません');
	}, null, function (argc) {
		return argc[0].makePython() + '.insert(0, ' + argc[1].makePython() + ')\n';
	}),
};

/**
 * 命令クラス
 */
class Statement {
	/**
	 * @constructor
	 * @param {Location} loc
	 */
	constructor(loc) {
		this._loc = loc;
		this.state = 0;
	}
	get first_line() { return this._loc.first_line; }
	get last_line() { return this._loc.last_line; }
	get loc() { return this._loc; }
	run() { throw new RuntimeError(this.first_line, "これを呼んではいけない"); }
	/**
	 *
	 * @param {number} indent
	 */
	makePython(indent) {
		return Parts.makeIndent(indent);
	}
	clone() {
		throw new RuntimeError(this.first_line, constructor_name(this) + "はcloneが作られていません");
	}
}

/**
 * 手続き定義クラス
 */
class DefineStep extends Statement {
	/**
	 * @constructor
	 * @param {string} funcName
	 * @param {Array<Value>} params
	 * @param {Array<Statement>} statementlist
	 * @param {Location} loc
	 */
	constructor(funcName, params, statementlist, loc) {
		super(loc);
		if (definedFunction[funcName]) throw new RuntimeError(this.first_line, '手続き ' + funcName + ' と同名の標準関数が存在します');
		if (definedStep[funcName]) throw new RuntimeError(this.first_line, '手続き ' + funcName + ' と同名の標準手続きが存在します');
		if (myFuncs[funcName]) throw new RuntimeError(this.first_line, '手続き ' + funcName + ' と同名の関数、または手続きが既に定義されています');
		this.params = params;
		this.statementlist = statementlist;
		this.funcName = funcName;
		myFuncs[funcName] = this;
	}
	run() {
		code[0].stack[0].index++;
	}
	makePython(indent) {
		var code = "def " + this.funcName + '(';
		for (var i = 0; i < this.params.length; i++) {
			if (i > 0) code += ', ';
			code += this.params[i].varname;
		}
		code += '):\n';
		var codes = 0;
		for (var i = 0; i < this.statementlist.length; i++)
			if (this.statementlist[i]) {
				codes = 1;
				code += this.statementlist[i].makePython(1);
			}
		if (codes == 0) code += Parts.makeIndent(1) + "pass\n";
		return code;
	}
}

/**
 * 手続き呼び出しが終わった後の処理
 */
class afterCallStep {
	run() {
		varTables.shift();
		code.shift();
	}
}

/**
 * 手続き呼び出し
 */
class CallStep extends Statement {
	constructor(funcName, args, loc) {
		super(loc);
		this.funcName = funcName;
		this.args = args;
	}
	clone() {
		return new CallStep(this.funcName, this.args.clone(), this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.args, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			const fn = this.funcName
			const args = this.args;
			if (definedStep[fn]) {
				let step = definedStep[fn].clone();
				step.setParameter(args);
				step.setLocation(this.loc);
				let statementlist = [step];
				code.unshift(new parsedStep(statementlist));
			}
			else if (myFuncs[fn]) {
				let vt = new varTable();
				let globalVarTable = varTables[varTables.length - 1];
				for (let i of Object.keys(globalVarTable.vars))
					vt.vars[i] = globalVarTable.vars[i].getValue();
				for (let i = 0; i < myFuncs[fn].params.length; i++)
					vt.vars[myFuncs[fn].params[i].varname] = args[i].getValue();
				let statementlist = myFuncs[fn].statementlist.concat();
				// TODO 呼ばれる保証がない
				statementlist.push(new afterCallStep());
				code.unshift(new parsedStep(statementlist));
				varTables.unshift(vt);
			}
			else
				throw new RuntimeError(this.first_line, '手続き ' + fn + ' は定義されていません');
			this.state = 0;
		}
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		code += this.funcName + '(';
		for (var i = 0; i < this.args.length; i++) {
			if (i > 0) code += ', ';
			code += this.args[i].makePython(0);
		}
		return code + ')\n';
	}
}

class ExitStatement extends Statement {
	constructor(loc) {
		super(loc);
	}
	clone() {
		return new ExitStatement(this.loc);
	}
	run() {
		if (code[0] instanceof parsedStep) {
			code.shift();
			varTables.shift();
		}
		else throw new RuntimeError(this.first_line, "手続きの中ではありません");
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		code += "break\n";
		return code;
	}
}

class DefineFunction extends Statement {
	constructor(funcName, params, statementlist, loc) {
		super(loc);
		if (definedFunction[funcName]) throw new RuntimeError(this.first_line, '関数 ' + funcName + ' と同名の標準関数が存在します');
		if (myFuncs[funcName]) throw new RuntimeError(this.first_line, '関数 ' + funcName + ' と同名の関数、または手続きが既に定義されています');
		this.params = params;
		this.funcName = funcName;
		myFuncs[funcName] = this;
		this.statementlist = statementlist;
	}
	clone() {
		throw new RuntimeError(this.first_line, 'これはクローンされるべきでない');
	}
	run() {
		code[0].stack[0].index++;
	}
	makePython(indent) {
		var code = "def ";
		code += this.funcName + '(';
		for (var i = 0; i < this.params.length; i++) {
			if (i > 0) code += ', ';
			code += this.params[i].makePython();
		}
		code += '):\n';
		var codes = 0;
		for (var i = 0; i < this.statementlist.length; i++)
			if (this.statementlist[i]) {
				codes = 1;
				code += this.statementlist[i].makePython(1);
			}
		if (codes == 0) code += Parts.makeIndent(1) + "pass\n";
		return code;
	}
}

/**
 * 関数から値を返す
 */
class ReturnStatement extends Statement {
	constructor(value, loc) {
		super(loc);
		this.value = value.clone();
		this.caller = null;
		this.flag = false;
		this.state = 0;
	}
	clone() {
		let rtnv = new ReturnStatement(this.value.clone(), this.loc);
		rtnv.caller = this.caller;
		rtnv.flag = this.flag;
		return rtnv;
	}
	setCaller(caller, flag) {
		this.caller = caller;
		this.flag = flag;
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: [this.value], index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			if (code[0] instanceof parsedFunction) {
				this.caller.setValue(this.value.getValue());
				code.shift();
				if (this.flag) varTables.shift();
			}
			else throw new RuntimeError(this.first_line, "関数の中ではありません");
			this.state = 0;
		}
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		code += "return";
		if (this.value) code += ' ' + this.value.makePython();
		return code + "\n";
	}
}

class notReturnedFunction extends Statement {
	constructor(loc) { super(loc); }
	clone() {
		return new notReturnedFunction(this.loc);
	}
	run() {
		throw new RuntimeError(this.last_line, "関数が値を返さずに終了しました");
	}
	makePython() {
		return '';
	}
}

/**
 *
 */
function dump(message = null) {
	if (!message) message = "*** 変数確認 ***";
	output(message + "\n");
	var vars = varTables[0].varnames([]);
	if (varTables.length > 1) vars = varTables[varTables.length - 1].varnames(vars);
	for (var i = 0; i < vars.length; i++) {
		if (vars[i][0] == '!') continue;
		let vartable = findVarTable(vars[i]);
		let v = vartable.vars[vars[i]];
		output(vars[i] + ":" + array2code(v) + "\n");
	}
}

class DumpStatement extends Statement {
	constructor(loc) { super(loc); }
	clone() {
		return new DumpStatement(this.loc);
	}
	run() {
		dump();
		code[0].stack[0].index++;
	}
	makePython() {
		return '';
	}
}

/**
 * ArrayValueを文字列表現にする
 * @param {ArrayValue} args
 * @returns {string}
 */
function argsString(args) {
	if (args instanceof ArrayValue) {
		let a = [];
		for (let i = 0; i < args.value.length; i++) a.push(args.value[i].getValue().value);
		return '[' + a.join(',') + ']';
	}
	return '';
}

class Assign extends Statement {
	/**
	 * @constructor
	 * @param {Variable} variable
	 * @param {Value} value
	 * @param {String} operator
	 * @param {Location} loc
	 */
	constructor(variable, value, operator, loc) {
		super(loc);
		if (!(variable instanceof Variable || variable instanceof UNDEFINED)) throw new RuntimeError(loc.first_line, "変数でないものに代入はできません");
		this.variable = variable;
		this.value = value;
		this.operator = operator;
		this.state = 0;
	}
	clone() {
		return new Assign(this.variable, this.value, this.operator, this.loc);
	}
	run() {
		if (this.variable instanceof UNDEFINED) throw new RuntimeError(this.first_line, "未完成のプログラムです");
		if (this.state == 0) {
			let a = [];
			if (this.operator) a.push(this.variable);
			else if (this.variable.args) a = a.concat(this.variable.args.value);
			a.push(this.value);
			code[0].stack.unshift({ statementlist: a, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let vn = this.variable.varname;
			let ag = this.variable.args;
			let vl = this.value.getValue();
			let vt = findVarTable(vn);
			if (vt) // 変数が定義されている
			{
				let va = vt.vars[vn];
				if (this.operator) {
					va = getValueByArgs(va, ag ? ag.value : null, this.loc);
					let v1 = va.getValue(), v2 = vl, v3 = null;
					switch (this.operator) {
						case '+':
							if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
							if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
							if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列の足し算はまだサポートしていません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書の足し算はまだサポートしていません");
							else if (v1 instanceof StringValue || v2 instanceof StringValue) v3 = new StringValue(String(v1.value) + String(v2.value), this.loc);
							else if (v1 instanceof IntValue && v2 instanceof IntValue) v3 = new IntValue(v1.value + v2.value, this.loc);
							else if (v1 instanceof FloatValue || v2 instanceof FloatValue) v3 = new FloatValue(v1.value + v2.value, this.loc);
							break;
						case '-':
							if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
							if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
							if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列の引き算はできません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書の引き算はできません");
							else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列の引き算はできません");
							else if (v1 instanceof IntValue && v2 instanceof IntValue) v3 = new IntValue(v1.value - v2.value, this.loc);
							else if (v1 instanceof FloatValue || v2 instanceof FloatValue) v3 = new FloatValue(v1.value - v2.value, this.loc);
							break;
						case '*':
							if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
							if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
							if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列の掛け算は出来ません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書の掛け算はできません");
							else if (v1 instanceof StringValue) {
								if (v2 instanceof IntValue) v3 = new StringValue(v1.value.repeat(v2.value >= 0 ? v2.value : 0), this.loc);
								else throw new RuntimeError(this.first_line, "文字列に掛けられるのは整数だけです")
							}
							else if (v1 instanceof IntValue && v2 instanceof IntValue) v3 = new IntValue(v1.value * v2.value, this.loc);
							else if (v1 instanceof FloatValue || v2 instanceof FloatValue) v3 = new FloatValue(v1.value * v2.value, this.loc);
							break;
						case '/':
							if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
							if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
							if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列の割り算はできません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書の割り算はできません");
							else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列の割り算はできません");
							else {
								if (v2.value == 0) throw new RuntimeError(this.first_line, '0で割り算をしました');
								else v3 = new FloatValue(v1.value / v2.value, this.loc);
							}
							break;
						case '//':
							if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
							if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
							if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列の割り算はできません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書の割り算はできません");
							else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列の割り算はできません");
							else {
								if (v2.value == 0) throw new RuntimeError(this.first_line, '0で割り算をしました');
								let v4 = Math.floor(v1.value / v2.value);
								if (v1 instanceof IntValue && v2 instanceof IntValue) v3 = new IntValue(v4, this.loc);
								else v3 = new FloatValue(v4, this.loc);
							}
							break;
						case '%':
							if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
							if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
							if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列の割り算はできません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書の割り算はできません");
							else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列の割り算はできません");
							else {
								if (v2.value == 0) throw new RuntimeError(this.first_line, '0で割り算をしました');
								let v4 = v1.value - Math.floor(v1.value / v2.value) * v2.value;
								if (v1 instanceof IntValue && v2 instanceof IntValue) v3 = new IntValue(v4, this.loc);
								else v3 = new FloatValue(v4, this.loc);
							}
							break;
						case '&':
							if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のビット積はできません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書のビット積はできません");
							else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のビット積はできません");
							else if (v1 instanceof FloatValue || v2 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数のビット積はできません");
							else if (v1 instanceof BooleanValue && v2 instanceof BooleanValue) v3 = new BooleanValue(v1.value && v2.value, this.loc);
							else {
								if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
								if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
								v3 = new IntValue(v1.value & v2.value, this.loc);
							}
							break;
						case '|':
							if (v1 instanceof ArrayValue || v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のビット和はできません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書のビット和はできません");
							else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のビット和はできません");
							else if (v1 instanceof FloatValue || v2 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数のビット和はできません");
							else if (v1 instanceof BooleanValue && v2 instanceof BooleanValue) v3 = new BooleanValue(v1.value && v2.value, this.loc);
							else {
								if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
								if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
								v3 = new IntValue(v1.value | v2.value, this.loc);
							}
							break;
						case '^':
							if (v1 instanceof ArrayValue && v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列の排他的論理和はできません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書の排他的論理和はできません");
							else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列の排他的論理和はできません");
							else if (v1 instanceof FloatValue || v2 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数の排他的論理和はできません");
							else if (v1 instanceof BooleanValue && v2 instanceof BooleanValue) v3 = new BooleanValue(v1.value && v2.value, this.loc);
							else {
								if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
								if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
								v3 = new IntValue(v1.value ^ v2.value, this.loc);
							}
							break;
						case '<<':
							if (v1 instanceof ArrayValue && v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のビットシフトはできません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書のビットシフトはできません");
							else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のビットシフトはできません");
							else if (v1 instanceof FloatValue || v2 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数のビットシフトはできません");
							else if (v1 instanceof BooleanValue && v2 instanceof BooleanValue) v3 = new BooleanValue(v1.value && v2.value, this.loc);
							else {
								if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
								if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
								v3 = new IntValue(v1.value << v2.value, this.loc);
							}
							break;
						case '>>':
							if (v1 instanceof ArrayValue && v2 instanceof ArrayValue) throw new RuntimeError(this.first_line, "配列のビットシフトはできません");
							else if (v1 instanceof DictionaryValue || v2 instanceof DictionaryValue) throw new RuntimeError(this.first_line, "辞書のビットシフトはできません");
							else if (v1 instanceof StringValue || v2 instanceof StringValue) throw new RuntimeError(this.first_line, "文字列のビットシフトはできません");
							else if (v1 instanceof FloatValue || v2 instanceof FloatValue) throw new RuntimeError(this.first_line, "実数のビットシフトはできません");
							else if (v1 instanceof BooleanValue && v2 instanceof BooleanValue) v3 = new BooleanValue(v1.value && v2.value, this.loc);
							else {
								if (v1 instanceof BooleanValue) v1 = new IntValue(v1.value ? 1 : 0, this.loc);
								if (v2 instanceof BooleanValue) v2 = new IntValue(v2.value ? 1 : 0, this.loc);
								v3 = new IntValue(v1.value >> v2.value, this.loc);
							}
							break;
					}
					if (!v3) throw new RuntimeError(this.first_line, '複合代入演算子の使い方が間違っています');
					setVariableByArgs(vt, vn, ag ? ag.value : null, v3, this.loc);
				}
				else setVariableByArgs(vt, vn, ag ? ag.value : null, vl, this.loc);
			}
			else // 変数が定義されていない
			{
				if (this.operator) throw new RuntimeError(this.first_line, '宣言されていない変数に複合代入演算子が使われました');
				vt = varTables[0];
				vt.vars[vn] = new NullValue(this.loc);
				setVariableByArgs(vt, vn, ag ? ag.value : null, vl, this.loc);
			}
			this.state = 0;
		}
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		code += this.variable.makePython() + " ";
		if (this.operator) code += this.operator;
		code += "= " + this.value.makePython() + "\n";
		return code;
	}
}

class Append extends Statement {
	/**
	 * @constructor
	 * @param {Variable} variable
	 * @param {Value} value
	 * @param {Location} loc
	 */
	constructor(variable, value, loc) {
		super(loc);
		if (!(variable instanceof Variable || variable instanceof UNDEFINED)) throw new RuntimeError(loc.first_line, "追加されるものは変数でなくてはいけません");
		this.variable = variable;
		this.value = value;
		this.state = 0;
	}
	clone() {
		return new Append(this.variable.clone(), this.value.clone(), this.loc);
	}
	run() {
		if (this.variable instanceof UNDEFINED) throw new RuntimeError(this.first_line, "未完成のプログラムです");
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: [this.variable, this.value], index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let vn = this.variable.varname;
			let ag = this.variable.args;
			let vl = this.value.getValue();
			let vt = findVarTable(vn);
			if (vt) // 変数が定義されている
			{
				let va = vt.vars[vn];
				if (ag && ag.value.length > 0) // 配列の添字がある
				{
					for (let i = 0; i < ag.value.length; i++) {
						if (ag.value[i].getValue() instanceof StringValue) {
							va = va.value[ag.value[i].getValue().value];
						}
						else if (ag.value[i].getValue() instanceof IntValue) {
							if (va.value[ag.value[i].getValue().value])
								va = va.value[ag.value[i].getValue().value];
							else throw new RuntimeError(this.first_line, '配列の範囲を超えたところに追加しようとしました')
						}
						else throw new RuntimeError(this.first_line, '添字に使えないデータ型です');
					}
				}
				if (va instanceof ArrayValue) va.value.push(vl.clone());
				else throw new RuntimeError(this.first_line, '配列でない変数に追加はできません');
			}
			else // 変数が定義されていない
				throw new RuntimeError(this.first_line, '存在しない配列に追加はできません');
			this.state = 0;
		}
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		code += this.variable.makePython() + ".append(" + this.value.makePython() + ")\n";
		return code;
	}
}

class Extend extends Statement {
	/**
	 * @constructor
	 * @param {Variable} variable
	 * @param {Value} value
	 * @param {Location} loc
	 */
	constructor(variable, value, loc) {
		super(loc);
		if (!(variable instanceof Variable || variable instanceof UNDEFINED)) throw new RuntimeError(loc.first_line, "連結されるものは変数でなくてはいけません");
		this.variable = variable;
		this.value = value;
		this.state = 0;
	}
	clone() {
		return new Extend(this.variable.clone(), this.value.clone(), this.loc);
	}
	run() {
		if (this.variable instanceof UNDEFINED) throw new RuntimeError(this.first_line, "未完成のプログラムです");
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: [this.variable, this.value], index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let vn = this.variable.varname;
			let ag = this.variable.args;
			let vl = this.value.getValue();
			let vt = findVarTable(vn);
			if (vt) // 変数が定義されている
			{
				let va = vt.vars[vn];
				if (ag && ag.value.length > 0) // 配列の添字がある
				{
					for (let i = 0; i < ag.value.length; i++) {
						ag.value[i].run();
						if (ag.value[i] instanceof StringValue) {
							va = va.value[ag.value[i].getValue().value];
						}
						else if (ag.value[i] instanceof IntValue) {
							if (va.value[ag.value[i].getValue().value])
								va = va.value[ag.value[i].getValue().value];
							else throw new RuntimeError(this.first_line, '配列の範囲を超えたところに連結しようとしました')
						}
						else throw new RuntimeError(this.first_line, "添字に使えないデータ型です");
					}
				}
				if (va instanceof ArrayValue) {
					if (vl instanceof ArrayValue) {
						var l = vl.value.length;
						for (var i = 0; i < l; i++) va.value.push(vl.value[i].clone());
					}
					else throw new RuntimeError(this.first_line, '配列でない値を連結することはできません');
				}
				else throw new RuntimeError(this.first_line, '配列でない変数に連結はできません');
			}
			else // 変数が定義されていない
				throw new RuntimeError(this.first_line, '存在しない配列に連結はできません');
			this.state = 0;
		}
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		code += this.variable.makePython() + ".extend(" + this.value.makePython() + ")\n";
		return code;
	}
}

class Input extends Statement {
	constructor(x, type, loc) {
		super(loc);
		if (!(x instanceof Variable || x instanceof UNDEFINED)) throw new RuntimeError(loc.first_line, "入力されるものは変数でなくてはいけません");
		this.varname = x;
		this.type = type;
		this.state = 0;
	}
	clone() {
		return new Input(this.varname.clone(), this.type, this.loc);
	}
	run() {
		if (selected_quiz < 0)	// 通常時
		{
			code[0].stack[0].index++;
			if (this.varname instanceof UNDEFINED) throw new RuntimeError(this.first_line, "未完成のプログラムです");
			var list = [new InputBegin(this.loc), new InputEnd(this.varname, this.type, this.loc)];
			code[0].stack.unshift({ statementlist: list, index: 0 });
		}
		else	// 自動採点時
		{
			if (this.state == 0) {
				if (this.varname.args) code[0].stack.unshift({ statementlist: this.varname.args, index: 0 });
				this.state = 1;
			}
			else {
				code[0].stack[0].index++;
				if (selected_quiz_input < Quizzes[selected_quiz].inputs(selected_quiz_case).length) {
					if (this.varname instanceof UNDEFINED) throw new RuntimeError(this.first_line, "未完成のプログラムです");
					let va = new Variable(this.varname.varname, this.varname.args, this.loc);
					let vl = Quizzes[selected_quiz].inputs(selected_quiz_case)[selected_quiz_input++];
					// va.run();
					let assign = null;
					let re = /^(0+|false|偽|)$/i;
					if (this.type == typeOfValue.typeInt) assign = new Assign(this.varname, new IntValue(Number(toHalf(vl, this.loc)), this.loc), null, this.loc);
					else if (this.type == typeOfValue.typeFloat) assign = new Assign(this.varname, new FloatValue(Number(toHalf(vl, this.loc)), this.loc), null, this.loc);
					else if (this.type == typeOfValue.typeString) assign = new Assign(this.varname, new StringValue(vl + '', this.loc), null, this.loc);
					else if (this.type == typeOfValue.typeBoolean) assign = new Assign(this.varname, new BooleanValue(!re.exec(vl), this.loc), null, this.loc);
					code[0].stack.unshift({ statementlist: [assign], index: 0 });
				}
				else throw new RuntimeError(this.first_line, '必要以上の入力を求めています。');
				this.state = 0;
			}
		}
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		code += this.varname.makePython() + " = ";
		switch (this.type) {
			case typeOfValue.typeInt: code += "int(input())\n"; break;
			case typeOfValue.typeFloat: code += "float(input())\n"; break;
			case typeOfValue.typeString: code += "input()\n"; break;
			case typeOfValue.typeBoolean: code += "bool(input())\n"; break;
		}
		return code;
	}
}

class InputBegin extends Statement {
	/**
	 * @constructor
	 * @param {Location} loc
	 */
	constructor(loc) {
		super(loc);
	}
	clone() {
		return new InputBegin(this.loc);
	}
	run() {
		openInputWindow();
		code[0].stack[0].index++;
	}
}

class InputEnd extends Statement {
	/**
	 * @constructor
	 * @param {Variable} x
	 * @param {typeOfValue} type
	 * @param {Location} loc
	 */
	constructor(x, type, loc) {
		super(loc);
		this.varname = x;
		this.type = type;
		this.state = 0;
	}
	clone() {
		return new InputEnd(this.varname.clone(), this.type, this.loc);
	}
	run() {
		if (this.varname instanceof UNDEFINED) throw new RuntimeError(this.first_line, "未完成のプログラムです");
		if (this.state == 0) {
			if (this.varname.args) code[0].stack.unshift({ statementlist: this.varname.args, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			try {
				let vl = closeInputWindow();
				// va.run();
				let assign = null;
				let re = /^(0+|false|偽|)$/i;
				if (this.type == typeOfValue.typeInt) assign = new Assign(this.varname, new IntValue(Number(toHalf(vl, this.loc)), this.loc), null, this.loc);
				else if (this.type == typeOfValue.typeFloat) assign = new Assign(this.varname, new FloatValue(Number(toHalf(vl, this.loc)), this.loc), null, this.loc);
				else if (this.type == typeOfValue.typeString) assign = new Assign(this.varname, new StringValue(vl + '', this.loc), null, this.loc);
				else if (this.type == typeOfValue.typeBoolean) assign = new Assign(this.varname, new BooleanValue(!re.exec(vl), this.loc), null, this.loc);
				code[0].stack.unshift({ statementlist: [assign], index: 0 });
			}
			catch (e) {
				closeInputWindow();
				throw e;
			}
			this.state = 0;
		}
	}
}

class Newline extends Statement {
	constructor(loc) { super(loc); }
	clone() {
		return new Newline(this.loc);
	}
	run() {
		code[0].stack[0].index++;
		if (selected_quiz < 0) {
			output("\n");
		}
		else {
			output_str += "\n";
		}
	}
	makePython(indent) {
		return Parts.makeIndent(indent) + "print()\n";
	}
}

class Output extends Statement {
	/**
	 *
	 * @param {Array<Value>} x
	 * @param {boolean} ln
	 * @param {Location} loc
	 */
	constructor(x, ln, loc) {
		super(loc);
		this.value = x;
		this.ln = ln;
		this.state = 0;
	}
	clone() {
		var val = [];
		for (var i = 0; i < this.value.length; i++) val.push(this.value[i].clone());
		return new Output(val, this.ln, this.loc);
	}
	run() {
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: this.value, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let s = '';
			for (var i = 0; i < this.value.length; i++) {
				let v = this.value[i];
				s += (i > 0 ? ' ' : '') + array2text(v);
			}
			if (this.ln) s += '\n';
			if (selected_quiz < 0) output(s);
			else output_str += s;
			this.state = 0;
		}
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		code += "print(";
		for (var i = 0; i < this.value.length; i++)
			code += (i > 0 ? ', ' : '') + this.value[i].makePython();
		if (!this.ln) code += ",end=''";
		return code + ")\n";
	}
}

function array2text(v) {
	if (!v) return '';
	if (v instanceof Value) {
		let v0 = v.getValue();
		if (v0 instanceof ArrayValue) {
			let v1 = [];
			for (let i = 0; i < v0.value.length; i++) {
				v1.push(array2text(v0.value[i]));
			}
			return '[' + v1.join(',') + ']';
		}
		else if (v0 instanceof DictionaryValue) {
			let v1 = [];
			let keys = Object.keys(v0.value);
			keys.sort();
			for (let i = 0; i < keys.length; i++) {
				v1.push(keys[i] + ':' + array2text(v0.value[keys[i]]));
			}
			return '{' + v1.join(',') + '}';
		}
		else if (v0 instanceof BooleanValue) return v0.value ? 'True' : 'False';
		else if (v0 instanceof FloatValue && isInteger(v0.value) && !v0.value.toString().match(/[Ee]/)) return v0.value + '.0';
		else return new String(v0.value);
	}
	else return new String(v);
}

function array2code(v) {
	if (!v) return '';
	let v0 = v;
	if (v0 instanceof ArrayValue) {
		let v1 = [];
		for (let i = 0; i < v0.value.length; i++) v1.push(array2text(v0.value[i]));
		return '[' + v1.join(',') + ']';
	}
	else if (v0 instanceof DictionaryValue) {
		let v1 = [];
		let keys = Object.keys(v0.value);
		keys.sort();
		for (let i = 0; i < keys.length; i++) v1.push(keys[i] + ':' + array2text(v0.value[keys[i]]));
		return '{' + v1.join(',') + '}';
	}
	else if (v0 instanceof StringValue) return '"' + v0.value + '"';
	else if (v0 instanceof FloatValue && isInteger(v0.value) && !v0.value.toString().match(/[Ee]/)) return v0.value + '.0';
	return v0.value;
}

class GraphicStatement extends Statement {
	constructor(command, args, loc) {
		super(loc);
		this.command = command;
		this.args = args;
		this.state = 0;
	}
	clone() {
		var args = [];
		for (var i = 0; i < this.args.length; i++) args.push(this.args[i].clone());
		return new GraphicStatement(this.command, args, this.loc);
	}
	run() {
		if (this.state == 0) {
			if (this.args) code[0].stack.unshift({ statementlist: this.args, index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			if (this.command == 'gOpenWindow') {
				canvas = new OffscreenCanvas(this.args[0].getValue().value, this.args[1].getValue().value);
				context = canvas.getContext('2d');
			}
			else if (this.command == 'gCloseWindow') {
				canvas = null;
				context = null;
			}
			else if (this.command == 'gClearWindow') {
				context.clearRect(0, 0, canvas.width, canvas.height)
			}
			else if (this.command == 'gSetLineColor') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let r = this.args[0].getValue().value, g = this.args[1].getValue().value, b = this.args[2].getValue().value;
				context.strokeStyle = "rgb(" + r + "," + g + "," + b + ")";
			}
			else if (this.command == 'gSetFillColor') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let r = this.args[0].getValue().value, g = this.args[1].getValue().value, b = this.args[2].getValue().value;
				context.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
			}
			else if (this.command == 'gSetTextColor') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let r = this.args[0].getValue().value, g = this.args[1].getValue().value, b = this.args[2].getValue().value;
				context.textStyle = "rgb(" + r + "," + g + "," + b + ")";
			}
			else if (this.command == 'gSetLineWidth') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				context.lineWidth = this.args[0].getValue().value;
			}
			else if (this.command == 'gSetFontSize') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				context.font = this.args[0].getValue().value + "px 'sans-serif'";
			}
			else if (this.command == 'gDrawText') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				var temp = context.fillStyle;
				context.fillStyle = context.textStyle;
				context.fillText(this.args[0].getValue().value, this.args[1].getValue().value, this.args[2].getValue().value);
				context.fillStyle = temp;
			}
			else if (this.command == 'gDrawLine') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let x1 = this.args[0].getValue().value, y1 = this.args[1].getValue().value,
					x2 = this.args[2].getValue().value, y2 = this.args[3].getValue().value;
				context.beginPath();
				context.moveTo(x1, y1);
				context.lineTo(x2, y2);
				context.stroke();
			}
			else if (this.command == 'gDrawPoint') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let x1 = this.args[0].getValue().value, y1 = this.args[1].getValue().value;
				context.beginPath();
				context.arc(x1, y1, 1, 0, Math.PI * 2, false);
				context.stroke();
			}
			else if (this.command == 'gDrawBox') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let x1 = this.args[0].getValue().value, y1 = this.args[1].getValue().value,
					width = this.args[2].getValue().value, height = this.args[3].getValue().value;
				context.beginPath();
				context.strokeRect(x1, y1, width, height);
				context.stroke();
			}
			else if (this.command == 'gFillBox') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let x1 = this.args[0].getValue().value, y1 = this.args[1].getValue().value,
					width = this.args[2].getValue().value, height = this.args[3].getValue().value;
				context.fillRect(x1, y1, width, height);
				context.beginPath();
				context.strokeRect(x1, y1, width, height);
				context.stroke();
			}
			else if (this.command == 'gDrawCircle') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let x1 = this.args[0].getValue().value, y1 = this.args[1].getValue().value, r = this.args[2].getValue().value;
				context.beginPath();
				context.arc(x1, y1, r, 0, Math.PI * 2, false);
				context.stroke();
			}
			else if (this.command == 'gFillCircle') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let x1 = this.args[0].getValue().value, y1 = this.args[1].getValue().value, r = this.args[2].getValue().value;
				for (var i = 0; i < 2; i++) {
					context.beginPath();
					context.arc(x1, y1, r, 0, Math.PI * 2, false);
					if (i == 0) context.fill();
					else context.stroke();
				}
			}
			else if (this.command == 'gDrawOval') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let x1 = this.args[0].getValue().value, y1 = this.args[1].getValue().value, w = this.args[2].getValue().value, h = this.args[3].getValue().value;
				context.beginPath();
				context.ellipse(x1 + w / 2, y1 + h / 2, w / 2, h / 2, 0, 0, Math.PI * 2);
				context.stroke();
			}
			else if (this.command == 'gFillOval') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let x1 = this.args[0].getValue().value, y1 = this.args[1].getValue().value, w = this.args[2].getValue().value, h = this.args[3].getValue().value;
				for (var i = 0; i < 2; i++) {
					context.beginPath();
					context.ellipse(x1 + w / 2, y1 + h / 2, w / 2, h / 2, 0, 0, Math.PI * 2);
					if (i == 0) context.fill();
					else context.stroke();
				}
			}
			else if (this.command == 'gDrawArc') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let x1 = this.args[0].getValue().value, y1 = this.args[1].getValue().value, w = this.args[2].getValue().value, h = this.args[3].getValue().value,
					theta1 = this.args[4].getValue().value, theta2 = this.args[5].getValue().value, style = this.args[6].getValue().value;
				context.beginPath();
				context.ellipse(x1 + w / 2, y1 + h / 2, w / 2, h / 2, 0, -theta1 * Math.PI / 180, -theta2 * Math.PI / 180, true);
				switch (style) {
					case 2: // 半径
						context.lineTo(x1 + w / 2, y1 + h / 2);
					// fall through
					case 1: // 弦
						context.closePath();
				}
				context.stroke();
			}
			else if (this.command == 'gFillArc') {
				if (context == null) throw new RuntimeError(this.first_line, "描画領域がありません");
				let x1 = this.args[0].getValue().value, y1 = this.args[1].getValue().value, w = this.args[2].getValue().value, h = this.args[3].getValue().value,
					theta1 = this.args[4].getValue().value, theta2 = this.args[5].getValue().value, style = this.args[6].getValue().value;
				for (var i = 0; i < 2; i++) {
					context.beginPath();
					context.ellipse(x1 + w / 2, y1 + h / 2, w / 2, h / 2, 0, -theta1 * Math.PI / 180, -theta2 * Math.PI / 180, true);
					switch (style) {
						case 2: // 半径
							context.lineTo(x1 + w / 2, y1 + h / 2);
						// fall through
						case 1: // 弦
							context.closePath();
					}
					if (i == 0) context.fill();
					else context.stroke();
				}
			}
			else if (this.command == 'gBarplot') {
				if (context == null) {
					var w = this.args[0].getValue().value, h = this.args[1].getValue().value;
					canvas = new OffscreenCanvas(w, h);
					context = canvas.getContext('2d');
				}
				// 値の取得
				var values = array2values(this.args[2], this.loc);
				var max = 0, min = 0, maxn = 0;
				for (var i = 0; i < values.length; i++) {
					var l = values[i].length;
					if (l > maxn) maxn = l;
					for (var j = 0; j < l; j++) {
						var v1 = values[i][j];
						if (v1 > max) max = v1;
						if (v1 < min) min = v1;
					}
				}
				if (max == 0) max = 1;
				// 軸の描画
				var x0 = w * 0.05, y0 = h * 0.95;
				y0 *= max / (max - min);
				w *= 0.9; h *= 0.9;
				context.beginPath();
				context.moveTo(x0, y0 - h * max / (max - min));
				context.lineTo(x0, y0 - h * min / (max - min));
				context.moveTo(x0, y0);
				context.lineTo(x0 + w, y0);
				context.stroke();
				if (values.length > 0) {
					var w0 = w / maxn / values.length;
					for (var i = 0; i < values.length; i++) {
						context.fillStyle = graphColor[i % 6];
						context.beginPath();
						for (var j = 0; j < values[i].length; j++) {
							var x = x0 + w0 * j + w0 / 2, y = y0 - (values[i][j] / (max - min)) * h;
							if (values[i][j] >= 0)
								context.fillRect(x0 + w0 * j * values.length + w0 * 0.8 * i + w0 * 0.1, y0 - h * (values[i][j] / (max - min)), w0 * 0.8, h * (values[i][j] / (max - min)));
							else
								context.fillRect(x0 + w0 * j * values.length + w0 * 0.8 * i + w0 * 0.1, y0, w0 * 0.8, h * (-values[i][j] / (max - min)));
						}
						context.stroke();
					}
				}
			}
			else if (this.command == 'gLineplot') {
				if (context == null) {
					var w = this.args[0].getValue().value, h = this.args[1].getValue().value;
					canvas = new OffscreenCanvas(w, h);
					context = canvas.getContext('2d');
				}
				// 値の取得
				var values = array2values(this.args[2], this.loc);
				var max = 0, min = 0, maxn = 0;
				for (var i = 0; i < values.length; i++) {
					var l = values[i].length;
					if (l > maxn) maxn = l;
					for (var j = 0; j < l; j++) {
						var v1 = values[i][j];
						if (v1 > max) max = v1;
						if (v1 < min) min = v1;
					}
				}
				if (max == 0) max = 1;
				// 軸の描画
				var x0 = w * 0.05, y0 = h * 0.95;
				y0 *= max / (max - min);
				w *= 0.9; h *= 0.9;
				context.beginPath();
				context.moveTo(x0, y0 - h * max / (max - min));
				context.lineTo(x0, y0 - h * min / (max - min));
				context.moveTo(x0, y0);
				context.lineTo(x0 + w, y0);
				context.stroke();
				if (values.length > 0) {
					var w0 = w / maxn;
					for (var i = 0; i < values.length; i++) {
						context.strokeStyle = graphColor[i % 6];
						context.beginPath();
						for (var j = 0; j < values[i].length; j++) {
							var x = x0 + w0 * j + w0 / 2, y = y0 - (values[i][j] / (max - min)) * h;
							if (j == 0) context.moveTo(x, y);
							else context.lineTo(x, y);
						}
						context.stroke();
					}
				}
			}
			else if (this.command == 'gDrawGraph') {
				drawGraph(this.args[0].getValue(), this.args[1].getValue(), this.loc);
			}
			else if (this.command == 'gClearGraph') {
				clearGraph();
			}
			else {
				throw new RuntimeError(this.first_line, "未実装のコマンド" + this.command + "が使われました");
			}
			this.state = 0;
		}
	}
	makePython(indent) {
		throw new RuntimeError(this.first_line, "グラフィック命令はPythonに変換できません");
	}
}

function clearGraph() {
	Plotly.purge(document.getElementById("graph"));
}

// グラフ描画を行う
// graph{
//  title: 文字列
//  x:{
// 	  title: 文字列
//    min: 実数
//    max: 実数
//  }
//  y:{
// 	  title:
//    min:
//    max:
//  }
// }
// dataは{
//   x: 値の配列（省略時は0〜len(y)-1）
//   y: 値の配列（省略不可）
//   type: 'bar' or 'line' or 'scatter'
//   color:
//   size: 整数（省略時は1）
// }の配列
function drawGraph(layout, data, loc) {
	var div = document.getElementById('graph');
	var graph_data = [], graph_layout = {};
	if (layout instanceof DictionaryValue) {
		for (var key in layout.value) {
			var val = layout.value[key].getValue();
			if (val instanceof ArrayValue) {
				graph_layout[key] = {};
				for (var key1 in val.value)
					graph_layout[key][key1] = val2obj(val.value[key1].getValue());
			}
			else graph_layout[key] = val2obj(val);
		}
	}
	else if (layout) throw new RuntimeError(loc.first_line, "レイアウト情報が辞書になっていません");
	if (data instanceof ArrayValue) {
		var dl = data.value.length;
		for (var i = 0; i < dl; i++) {
			var d = data.value[i].getValue();
			if (d instanceof DictionaryValue) {
				var va = {};
				for (var key in d.value) {
					var val = d.value[key].getValue();
					va[key] = val2obj(val);
				}
				graph_data.push(va);

			}
			else throw new RuntimeError(loc.first_line, "データの" + i + "番目の要素が辞書になっていません");
		}
	} else throw new RuntimeError(loc.first_line, 'データが配列になっていません');
	Plotly.newPlot(div, graph_data, graph_layout);
}

function val2obj(val) {
	if (val instanceof ArrayValue) {
		var rtnv = [];
		var l = val.value.length;
		for (var i = 0; i < l; i++) rtnv.push(val2obj(val.value[i]));
		return rtnv;
	}
	else if (val instanceof DictionaryValue) {
		var rtnv = {};
		for (var key in val.value)
			rtnv[key] = val2obj(val.value[key].getValue());
		return rtnv;
	}
	else return val.value;
}

/**
 *
 * @param {ArrayValue} a
 * @param {Location} loc
 */
function array2values(a, loc) {
	var rtnv = [];
	var array = null;
	if (a.rtnv instanceof ArrayValue) {
		if (a.rtnv.value[0] instanceof ArrayValue) array = a.rtnv;
		else if (a.rtnv.value instanceof Array) array = new ArrayValue([a.rtnv.value], loc);
		else throw new RuntimeError(loc.first_line, "グラフに誤った型が使われています");
	}
	else if (a.rtnv instanceof Array) array = new ArrayValue(a.rtnv, loc);
	else throw new RuntimeError(loc.first_line, "棒グラフ・線グラフには配列が必要です");

	for (var i = 0; i < array.length; i++) {
		var rtnv1 = [];
		for (var j = 0; j < array.value[i].length; j++)
			rtnv1.push(array.value[i] instanceof ArrayValue ? array.value[i].value[j].value : array.value[i][j].value);
		rtnv.push(rtnv1);
	}
	return rtnv;
}



class If extends Statement {
	/**
	 *
	 * @param {Array} blocks
	 * @param {Location} loc
	 */
	constructor(blocks, loc) {
		super(loc);
		this.blocks = blocks;
		this.running = -1;
	}
	clone() {
		var newblock = [];
		for (var i = 0; i < this.blocks.length; i++) {
			var newblock1 = [];
			for (var j = 0; j < this.blocks[i][1].length; j++) if (this.blocks[i][1][j]) newblock1.push(this.blocks[i][1][j].clone());
			newblock.push([this.blocks[i][0] ? this.blocks[i][0].clone() : null, newblock1]);
		}
		return new If(newblock, this.loc);
	}
	run() {
		if (this.state == 0) {
			this.running = 0;
			this.state = 1;
		}
		else if (this.state == 1) {
			if (this.running < this.blocks.length) {
				if (this.blocks[this.running][0]) code[0].stack.unshift({ statementlist: [this.blocks[this.running][0]], index: 0 });
				this.state = 2;
			}
			else {
				this.state = 0;
				code[0].stack[0].index++;
			}
		}
		else if (this.state == 2) {
			var flag = this.blocks[this.running][0] ? this.blocks[this.running][0].getValue() : new BooleanValue(true, this.loc);
			if (flag instanceof BooleanValue) {
				if (flag.value) {
					code[0].stack[0].index++;
					this.state = 0;
					code[0].stack.unshift({ statementlist: this.blocks[this.running][1], index: 0 });
				}
				else {
					this.running++;
					this.state = 1;
				}
			}
			else throw new RuntimeError(this.first_line, "条件式が使われるべき場所なのに，条件式が使われていません");
		}
	}
	makePython(indent) {
		var code = '';
		for (var i = 0; i < this.blocks.length; i++) {
			if (i == 0) code += Parts.makeIndent(indent) + "if " + this.blocks[i][0].makePython(0) + ":\n";
			else if (this.blocks[i][0]) code += Parts.makeIndent(indent) + "elif " + this.blocks[i][0].makePython(0) + ":\n";
			else code += Parts.makeIndent(indent) + "else:\n";
			if (this.blocks[i][1] && this.blocks[i][1].length > 0) {
				for (var j = 0; j < this.blocks[i][1].length; j++)
					code += this.blocks[i][1][j].makePython(indent + 1);
			}
			else code += Parts.makeIndent(indent + 1) + "pass\n";
		}
		return code;
	}
}

class LoopBegin extends Statement {
	/**
	 * @constructor
	 * @param {Value} condition nullなら判定しない
	 * @param {boolean} continuous condition==continuousなら継続
	 * @param {Location} loc
	 */
	constructor(condition, continuous, loc) {
		super(loc);
		this.condition = condition;
		this.continuous = continuous;
		this.state = 0;
	}
	clone() {
		return new LoopBegin(this.condition ? this.condition.clone() : null, this.continuous, this.loc);
	}
	run() {
		if (this.state == 0) {
			if (this.condition) code[0].stack.unshift({ statementlist: [this.condition], index: 0 });
			this.state = 1;
		}
		else {
			if (!this.condition || this.condition.getValue().value == this.continuous) code[0].stack[0].index++;
			else code[0].stack[0].index = -1;
			this.state = 0;
		}
	}
}

class LoopEnd extends Statement {
	/**
	 * @constructor
	 * @param {Value} condition nullなら判定しない
	 * @param {boolean} continuous condition==continuousなら継続
	 * @param {Location} loc
	 */
	constructor(condition, continuous, loc) {
		super(loc);
		this.condition = condition;
		this.continuous = continuous;
		this.state = 0;
	}
	clone() {
		return new LoopEnd(this.condition ? this.condition.clone() : null, this.continuous, this.loc);
	}
	run() {
		if (this.state == 0) {
			if (this.condition) code[0].stack.unshift({ statementlist: [this.condition], index: 0 });
			this.state = 1;
		}
		else {
			if (!this.condition || this.condition.getValue.value == this.continuous) code[0].stack[0].index = 0;
			else code[0].stack[0].index = -1;
			this.state = 0;
		}
	}
}

class ForIn extends Statement {
	constructor(array, variable, statementlist, loc) {
		super(loc);
		if (!(variable instanceof Variable || variable instanceof UNDEFINED)) throw new RuntimeError(loc.first_line, "繰り返しのカウンタは変数でなくてはいけません");
		this.array = array;
		this.variable = variable;
		this.statementlist = statementlist;
	}
	clone() {
		var state = [];
		for (var i = 0; i < this.statementlist.length; i++) if (this.statementlist[i]) state.push(this.statementlist[i].clone());
		return new ForIn(this.array.clone(), this.variable.clone(), state, this.loc);
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		var pa = this.array.makePython(), pv = this.variable.makePython();
		code += "for " + pv + " in " + pa + ":\n";
		var codes = 0;
		for (var i = 0; i < this.statementlist.length; i++)
			if (this.statementlist[i]) {
				codes = 1;
				code += this.statementlist[i].makePython(indent + 1);
			}
		if (codes == 0) code += Parts.makeIndent(indent + 1) + "pass\n";
		return code;
	}
	run() {
		if (this.varname instanceof UNDEFINED) throw new RuntimeError(this.first_line, "未完成のプログラムです");
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: [this.array], index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			let variable = new Variable(this.variable.varname, this.variable.args, this.loc);
			let loop = [new ForIn_step(this, variable, this.array, this.loc), new LoopBegin(new BooleanValue(true, this.loc), true, this.loc)];
			for (let i = 0; i < this.statementlist.length; i++)if (this.statementlist[i]) loop.push(this.statementlist[i].clone());
			loop.push(new LoopEnd(null, true, this.loc));
			code[0].stack.unshift({ statementlist: loop, index: 0 });
			this.state = 0;
		}
	}
}

class ForIn_step extends Statement {
	constructor(forin, variable, array, loc) {
		super(loc);
		this.forin = forin;
		this.variable = variable;
		this.array = array;
		this.index = 0;
	}
	clone() {
		return new ForIn_step(this.forin.clone(), this.variable.clone(), this.array.clone(), this.loc);
	}
	run() {
		code[0].stack[0].index++;
		if (this.index < this.array.rtnv.length) {
			let assign = new Assign(this.variable, this.array.rtnv.value[this.index++], null, this.loc);
			code[0].stack.unshift({ statementlist: [assign], index: 0 });
		}
		else {
			code[0].stack[0].statementlist[1] = new LoopBegin(new BooleanValue(false, true, this.loc), true, this.loc);
		}
	}
}

/**
 * forループ（加算）
 */
class ForInc extends Statement {
	/**
	 * @constructor
	 * @param {Variable} varname
	 * @param {Value} begin
	 * @param {Value} end
	 * @param {Value} step
	 * @param {Array<Statement>} statementlist
	 * @param {Location} loc
	 */
	constructor(varname, begin, end, step, statementlist, loc) {
		super(loc);
		if (!(varname instanceof Variable || varname instanceof UNDEFINED)) throw new RuntimeError(loc.first_line, "繰り返しのカウンタは変数でなくてはいけません");
		this.varname = varname;
		this.begin = begin;
		this.end = end;
		this.step = step;
		this.statementlist = statementlist;
		this.state = 0;
	}
	clone() {
		var state = [];
		for (var i = 0; i < this.statementlist.length; i++) if (this.statementlist[i]) state.push(this.statementlist[i].clone());
		return new ForInc(this.varname.clone(), this.begin.clone(), this.end.clone(), this.step.clone(), state, this.loc);
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		var pv = this.varname.makePython(), pb = this.begin.makePython(), pe = this.end.makePython(), ps = this.step.makePython();
		code += "for " + pv + " in range(" + pb + ", " + pe + "+1, " + ps + "):\n";
		var codes = 0;
		for (var i = 0; i < this.statementlist.length; i++)
			if (this.statementlist[i]) {
				codes = 1;
				code += this.statementlist[i].makePython(indent + 1);
			}
		if (codes == 0) code += Parts.makeIndent(indent + 1) + "pass\n";
		return code;
	}
	run() {
		if (this.varname instanceof UNDEFINED) throw new RuntimeError(this.first_line, "未完成のプログラムです");
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: [new Assign(this.varname, this.begin, null, this.loc)], index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			if (this.begin.getValue() instanceof IntValue || this.begin.getValue() instanceof FloatValue) {
				let variable = new Variable(this.varname.varname, this.varname.args, this.loc);
				let condition = new LE(variable, this.end, this.loc);	// IncとDecの違うところ
				let loop = [variable, condition, new LoopBegin(condition, true, this.loc)];
				for (let i = 0; i < this.statementlist.length; i++)if (this.statementlist[i]) loop.push(this.statementlist[i].clone());
				loop.push(this.step);
				loop.push(new Assign(variable, this.step, '+', this.loc));	// IncとDecの違うところ
				loop.push(new LoopEnd(null, true, this.loc));
				code[0].stack.unshift({ statementlist: loop, index: 0 });
			}
			else throw new RuntimeError(this.first_line, '初期値は数値型である必要があります');
			this.state = 0;
		}
	}
}

class ForDec extends Statement {
	constructor(varname, begin, end, step, statementlist, loc) {
		super(loc);
		if (!(varname instanceof Variable || varname instanceof Variable)) throw new RuntimeError(loc.first_line, "繰り返しのカウンタは変数でなくてはいけません");
		this.varname = varname;
		this.begin = begin;
		this.end = end;
		this.step = step;
		this.statementlist = statementlist;
		this.state = 0;
	}
	clone() {
		var state = [];
		for (var i = 0; i < this.statementlist.length; i++) if (this.statementlist[i]) state.push(this.statementlist[i].clone());
		return new ForDec(this.varname.clone(), this.begin.clone(), this.end.clone(), this.step.clone(), state, this.loc);
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		var pv = this.varname.makePython(), pb = this.begin.makePython(), pe = this.end.makePython(), ps = this.step.makePython();
		code += "for " + pv + " in range(" + pb + ", " + pe + "-1, -" + ps + "):\n";
		var codes = 0;
		for (var i = 0; i < this.statementlist.length; i++)
			if (this.statementlist[i]) {
				codes = 1;
				code += this.statementlist[i].makePython(indent + 1);
			}
		if (codes == 0) code += Parts.makeIndent(indent + 1) + "pass\n";
		return code;
	}
	run() {
		if (this.varname instanceof UNDEFINED) throw new RuntimeError(this.first_line, "未完成のプログラムです");
		if (this.state == 0) {
			code[0].stack.unshift({ statementlist: [new Assign(this.varname, this.begin, null, this.loc)], index: 0 });
			this.state = 1;
		}
		else {
			code[0].stack[0].index++;
			if (this.begin.getValue() instanceof IntValue || this.begin.getValue() instanceof FloatValue) {
				let variable = new Variable(this.varname.varname, this.varname.args, this.loc);
				let condition = new GE(variable, this.end, this.loc);	// IncとDecの違うところ
				let loop = [variable, condition, new LoopBegin(condition, true, this.loc)];
				for (let i = 0; i < this.statementlist.length; i++) if (this.statementlist[i]) loop.push(this.statementlist[i].clone());
				loop.push(this.step);
				loop.push(new Assign(variable, this.step, '-', this.loc));	// IncとDecの違うところ
				loop.push(new LoopEnd(null, true, this.loc));
				code[0].stack.unshift({ statementlist: loop, index: 0 });
			}
			else throw new RuntimeError(this.first_line, '初期値は数値型である必要があります');
			this.state = 0;
		}
	}
}

class While extends Statement {
	constructor(condition, statementlist, loc) {
		super(loc);
		this.condition = condition;
		this.statementlist = statementlist;
		this.status = 0;
	}
	clone() {
		var state = [];
		for (var i = 0; i < this.statementlist.length; i++) if (this.statementlist[i]) state.push(this.statementlist[i].clone());
		return new While(this.condition.clone(), state, this.loc);
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		code += "while " + this.condition.makePython() + ":\n";
		var codes = 0;
		for (var i = 0; i < this.statementlist.length; i++)
			if (this.statementlist[i]) {
				codes = 1;
				code += this.statementlist[i].makePython(indent + 1);
			}
		if (codes == 0) code += Parts.makeIndent(indent + 1) + "pass\n";
		return code;
	}
	run() {
		if (this.status == 0) {
			code[0].stack.unshift({ statementlist: [this.condition], index: 0 });
			this.status = 1;
		}
		else {
			code[0].stack[0].index++;
			let loop = [new LoopBegin(this.condition, true, this.loc)];
			for (var i = 0; i < this.statementlist.length; i++) if (this.statementlist[i]) loop.push(this.statementlist[i].clone());
			loop.push(new LoopEnd(null, false, this.loc));
			code[0].stack.unshift({ statementlist: loop, index: 0 });
			this.status = 0;
		}
	}
}

class SleepStatement extends Statement {
	constructor(sec, loc) {
		super(loc)
		this.sec = new IntValue(sec.value, loc); // milli seconds
	}
	clone() {
		return new SleepStatement(this.sec.clone(), this.loc);
	}
	run() {
		wait_time = this.sec.value;
		code[0].stack[0].index++;
	}
	makePython(indent) {
		var code = Parts.makeIndent(indent);
		python_lib["time"] = 1;
		return code + "time.sleep(" + this.sec.makePython() + " / 1000)\n";
	}
}

class NopStatement extends Statement {
	constructor(loc) { super(loc); }
	clone() { return new NopStatement(this.loc); }
	run() { code[0].stack[0].index++; }
	makePython(indent) {
		return Parts.makeIndent(indent) + "pass\n";
	}
}

class PauseStatement extends Statement {
	constructor(loc) { super(loc); }
	clone() { return new PauseStatement(this.loc); }
	run() { code[0].stack[0].index++; }
	makePython(indent) {
		return '';
	}
}


class BreakStatement extends Statement {
	constructor(loc) { super(loc); }
	clone() {
		return new BreakStatement(this.loc);
	}
	run() {
		while (true) {
			var block = code[0].stack.shift();
			if (!block) throw new RuntimeError(this.first_line, '繰り返しの中ではありません。');
			for (var i = 0; i < block.statementlist.length; i++)
				if (block.statementlist[i] instanceof LoopBegin) return;
		}
	}
	makePython(indent) {
		return Parts.makeIndent(indent) + "break\n";
	}
}

class Parts {
	constructor() {
		this._text = "";
		this._next = this._prev = null;
		this._textwidth = this._textheight = this._width = this._height = 0;
		this._hspace = this._hspace2 = 0;
	}
	get x1() { return this._x1; } set x1(x) { this._x1 = x; } // paintで計算する
	get y1() { return this._y1; } set y1(y) { this._y1 = y; }
	get x2() { return this._x2; } set x2(x) { this._x2 = x; }
	get y2() { return this._y2; } set y2(y) { this._y2 = y; }
	get text() { return this._text; }
	get next() { return this._next; }
	set next(p) {
		p._next = this.next;
		p._prev = this;
		if (this.next != null) this.next._prev = p;
		this._next = p;
	}
	get prev() { return this._prev; }
	get end() { return this; }						// ブロックの終わりのパーツ
	get width() { return this._width; }          // calcSizeで計算する
	get height() { return this._height; }         // calcSizeで計算する
	get textWidth() { return this._textwidth; }      // calcSizeで計算する
	get textHeight() { return this._textheight; }     // calcSizeで計算する
	get hspace() { return this._hspace; }
	get hspace2() { return this._hspace2; }

	get isBlockEnd() { return false; }

	inside(x, y) {
		return this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2;
	}
	findParts(x, y) {
		var p = this;
		while (p != null && !(p instanceof Parts_Null)) {
			if (p.inside(x, y)) return p;
			if (p instanceof Parts_If) {
				var p1 = p.left.findParts(x, y);
				if (p1) return p1;
				p1 = p.right.findParts(x, y);
				if (p1) return p1;
				p = p.end.next;
			}
			else p = p.next;
		}
		if (p != null && p.next != null) return p.next.findParts(x, y);
		return null;
	}

	paint(position) {
		if (this.next != null) return this.next.paint(position);
		return this;
	}
	calcTextsize() {
		if (this.text != null && this.text != "") {
			var size = FlowchartSetting.size;
			var metrics = flowchart.context.measureText(this.text);
			this._hspace = 0;
			this._textwidth = metrics.width;
			if (this._textwidth < size * 4) {
				this._hspace = (size * 4 - this._textwidth) / 2;
				this._textwidth = size * 4;
			}
			this._textheight = FlowchartSetting.fontsize;
		}
	}
	calcSize(p0, p1, p2) {
		if (this.next == null || this.isBlockEnd) return this;
		return this.next.calcSize(p0, p1, p2);
	}
	static appendMe(bar) {

	}
	appendCode(code, indent) {
		if (this.next != null) return this.next.appendCode(code, indent);
		return code;
	}
	static makeIndent(indent_level) {
		var s = "";
		for (var i = 0; i < indent_level; i++) s += "    ";
		return s;
	}
	editMe() {

	}
	deleteMe() {
		this.prev._next = this.end.next.next;
		this.end.next.next._prev = this.prev;
		this.end._next = null;
		this._next = null;
	}
	cutMe() {

	}

	paint_highlight() {
		flowchart.context.strokeStyle = "rgb(255,0,0)";
		flowchart.context.fillStyle = "rgb(255,0,0)";
		flowchart.context.clearRect(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
		this.paint(null);
		flowchart.context.strokeStyle = "rgb(0,0,0)";
		flowchart.context.fillStyle = "rgb(0,0,0)";
	}
	paint_unhighlight() {
		flowchart.context.clearRect(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
		this.paint(null);
	}

	highlight() {
		this.paint_highlight();
	}
	unhighlight() {
		this.paint_unhighlight();
	}
}

class Parts_Null extends Parts {
	get isBlockEnd() { return true; }
}

class Parts_Bar extends Parts {
	calcSize(p0, p1, p2) {
		this._width = 0;
		this._height = FlowchartSetting.size * 3;
		p0.y += this._height;
		if (p0.y > p2.y) p2.y = p0.y;
		return this.next.calcSize(p0, p1, p2);
	}
	inside(x, y) {
		var near = 4;
		return this.x1 - near <= x && x <= this.x2 + near && this.y1 <= y && y <= this.y2;
	}
	paint(position) {
		if (position != null) {
			this.x1 = this.x2 = position.x;
			this.y1 = position.y;
			this.y2 = this.y1 + this.height;
		}
		flowchart.context.beginPath();
		flowchart.context.moveTo(this.x1, this.y1);
		flowchart.context.lineTo(this.x2, this.y2);
		flowchart.context.stroke();
		if (position != null) {
			position.x = this.x2; position.y = this.y2;
			return this.next.paint(position);
		}
		return this;
	}
}

class Parts_Terminal extends Parts {
	calcSize(p0, p1, p2) {
		this.calcTextsize();    // textWidth, textHeightの計算
		this._height = this._textheight + FlowchartSetting.size * 2;
		this._width = this._textwidth + this._height;
		var x1 = p0.x - this.width / 2;
		var x2 = p0.x + this.width / 2;
		var y2 = p0.y + this.height;
		if (x1 < p1.x) p1.x = x1;
		if (x2 > p2.x) p2.x = x2;
		if (y2 > p2.y) p2.y = y2;
		p0.y = y2;
		if (this.next == null) return this;
		return this.next.calcSize(p0, p1, p2);
	}
	setValue(v) {
		this._text = v;
	}
	paint(position) {
		var size = FlowchartSetting.size;
		if (position != null) {
			this.x1 = position.x - this.textWidth / 2 - this.height / 2;
			this.x2 = position.x + this.textWidth / 2 + this.height / 2;
			this.y1 = position.y;
			this.y2 = position.y + this.height;
		}
		flowchart.context.beginPath();    // 上
		flowchart.context.moveTo(this.x1 + this.height / 2, this.y1);
		flowchart.context.lineTo(this.x2 - this.height / 2, this.y1);
		flowchart.context.stroke();
		flowchart.context.beginPath();    // 右
		flowchart.context.arc(this.x2 - this.height / 2, this.y1 + this.height / 2,
			this.height / 2, Math.PI / 2, - Math.PI / 2, true);
		flowchart.context.stroke();
		flowchart.context.beginPath();    // 下
		flowchart.context.moveTo(this.x1 + this.height / 2, this.y2);
		flowchart.context.lineTo(this.x2 - this.height / 2, this.y2);
		flowchart.context.stroke();
		flowchart.context.beginPath();    // 左
		flowchart.context.arc(this.x1 + this.height / 2, this.y1 + this.height / 2,
			this.height / 2, 3 * Math.PI / 2, Math.PI / 2, true);
		flowchart.context.stroke();
		flowchart.context.fillText(this.text, this.x1 + this.height / 2, this.y2 - FlowchartSetting.size);
		if (position != null) {
			position.y += this.height;
			if (this.end.next != null) return this.end.next.paint(position);
			return this.end;
		}
		return this;
	}
}

class Parts_Output extends Parts {
	constructor() {
		super();
		this.setValue("《値》", true);
	}
	get newline() { return this._newline; }
	setValue(v, nl) {
		this._text = v;
		this._newline = nl;
	}
	calcSize(p0, p1, p2) {
		this.calcTextsize();    // textWidth, textHeightの計算
		var size = FlowchartSetting.size;
		this._height = this._textheight + size * 2;
		this._width = this._textwidth + size * 2 + this._height / 2;
		var x1 = p0.x - this.width / 2;
		var x2 = p0.x + this.width / 2;
		var y2 = p0.y + this.height;
		if (x1 < p1.x) p1.x = x1;
		if (x2 > p2.x) p2.x = x2;
		if (y2 > p2.y) p2.y = y2;
		p0.y = y2;
		return this.next.calcSize(p0, p1, p2);
	}
	paint(position) {
		var size = FlowchartSetting.size;
		if (position != null) {
			this.x1 = position.x - this.width / 2;
			this.x2 = position.x + this.width / 2;
			this.y1 = position.y;
			this.y2 = this.y1 + this.height;
		}
		flowchart.context.beginPath();
		flowchart.context.moveTo(this.x2 - this.height / 2, this.y1);
		flowchart.context.lineTo(this.x1 + size * 2, this.y1);
		flowchart.context.lineTo(this.x1, (this.y1 + this.y2) / 2);
		flowchart.context.lineTo(this.x1 + size * 2, this.y2);
		flowchart.context.lineTo(this.x2 - this.height / 2, this.y2);
		flowchart.context.stroke();
		flowchart.context.beginPath();
		flowchart.context.arc(this.x2 - this.height / 2, (this.y1 + this.y2) / 2, this.height / 2,
			Math.PI / 2, -Math.PI / 2, true);
		flowchart.context.stroke();

		flowchart.context.fillText(this.text, this.x1 + size * 2 + this.hspace, this.y2 - size);

		if (!this.newline && this.text != '改行')	// 改行なしマーク
		{
			var x = this.x2 - this.height / 2;
			var y = this.y1 + size;
			flowchart.context.beginPath();
			flowchart.context.moveTo(x + size, y);
			flowchart.context.lineTo(x + size, y + this.textHeight);
			flowchart.context.lineTo(x, y + this.textHeight);
			flowchart.context.stroke();
			flowchart.context.beginPath();
			flowchart.context.moveTo(x + size / 2, y + this.textHeight - size / 4);
			flowchart.context.lineTo(x, y + this.textHeight);
			flowchart.context.lineTo(x + size / 2, y + this.textHeight + size / 4);
			flowchart.context.stroke();
			x += this.height / 4; y += this.textHeight / 2;
			flowchart.context.beginPath(); flowchart.context.moveTo(x - size / 2, y - size / 2); flowchart.context.lineTo(x + size / 2, y + size / 2); flowchart.context.stroke();
			flowchart.context.beginPath(); flowchart.context.moveTo(x + size / 2, y - size / 2); flowchart.context.lineTo(x - size / 2, y + size / 2); flowchart.context.stroke();
		}
		if (position != null) {
			position.y = this.y2;
			if (this.end.next != null) return this.end.next.paint(position);
			return this.end;
		}
		return this;
	}
	static appendMe(bar) {
		var parts = new Parts_Output();
		bar.next = parts;
		parts.next = new Parts_Bar();
		return parts.next;
	}
	appendCode(code, indent) {
		code += Parts.makeIndent(indent);
		if (this.text == '改行') code += '改行する\n';
		else code += (this.newline ? "" : "改行なしで") + "表示する(" + this.text + ")\n";
		if (this.next != null) return this.next.appendCode(code, indent);
		return code;
	}
	editMe() {
		var subtitle = ["値", "改行"];
		var values = [this.text, this.newline];
		openModalWindowforOutput("出力の編集", subtitle, values, this);
	}
	edited(values) {
		if (values != null) {
			this.setValue(values[0], values[1]);
		}
		flowchart.paint();
		flowchart.flowchart2code();
	}
}

class Parts_Input extends Parts {
	constructor() {
		super();
		this.setValue("《変数》", 0);
	}
	setValue(v, type) {
		this._var = v;
		this.type = type;
		this._text = v + "を入力"
		if (this.type > 0) this._text += "（" + nameOfType[this.type] + "）";
	}
	get var() { return this._var; }
	calcSize(p0, p1, p2) {
		this.calcTextsize();    // textWidth, textHeightの計算
		var size = FlowchartSetting.size;
		this._height = this._textheight + size * 2;
		this._width = this._textwidth + size * 4;
		var x1 = p0.x - this.width / 2;
		var x2 = p0.x + this.width / 2;
		var y2 = p0.y + this.height;
		if (x1 < p1.x) p1.x = x1;
		if (x2 > p2.x) p2.x = x2;
		if (y2 > p2.y) p2.y = y2;
		p0.y = y2;
		if (this.next == null || this.isBlockEnd) return this;
		return this.next.calcSize(p0, p1, p2);
	}
	paint(position) {
		var size = FlowchartSetting.size;
		if (position != null) {
			this.x1 = position.x - this.width / 2;
			this.x2 = position.x + this.width / 2;
			this.y1 = position.y;
			this.y2 = this.y1 + this.height;
		}
		flowchart.context.beginPath();
		flowchart.context.moveTo(this.x1, this.y1 + size);
		flowchart.context.lineTo(this.x2, this.y1 - size);
		flowchart.context.lineTo(this.x2, this.y2);
		flowchart.context.lineTo(this.x1, this.y2);
		flowchart.context.lineTo(this.x1, this.y1 + size);
		flowchart.context.stroke();
		flowchart.context.fillText(this.text, this.x1 + size * 2, this.y2 - size);
		if (position != null) {
			position.y = this.y2;
			if (this.end.next != null) return this.end.next.paint(position);
			return this.end;
		}
		return this;
	}
	static appendMe(bar) {
		var parts = new Parts_Input();
		bar.next = parts;
		parts.next = new Parts_Bar();
		return parts.next;
	}
	appendCode(code, indent) {
		code += Parts.makeIndent(indent);
		code += this.var;
		if (this.type > 0) code += "に" + nameOfType[this.type];
		code += "を入力する\n";
		if (this.next != null) return this.next.appendCode(code, indent);
		return code;
	}
	editMe() {
		var subtitle = ["変数", "型"];
		var values = [this.var, this.type];
		openModalWindowforInput("入力の編集", subtitle, values, this);
	}
	edited(values) {
		if (values != null) {
			this.setValue(values[0], values[1]);
		}
		flowchart.paint();
		flowchart.flowchart2code();
	}
}

class Parts_Substitute extends Parts {
	constructor() {
		super();
		this.setValue("《変数》", "《値》", null);
	}
	setValue(variable, value, operator) {
		this._var = variable;
		this._val = value;
		this._operator = operator

		this._text = this._var + (this._operator ? this._operator : '') + "=" + this._val;
	}
	get var() { return this._var; }
	get val() { return this._val; }
	get operator() { return this._operator; }
	calcSize(p0, p1, p2) {
		this.calcTextsize();    // textWidth, textHeightの計算
		var size = FlowchartSetting.size;
		this._height = this._textheight + size * 2;
		this._width = this._textwidth + size * 4;
		var x1 = p0.x - this.width / 2;
		var x2 = p0.x + this.width / 2;
		var y2 = p0.y + this.height;
		if (x1 < p1.x) p1.x = x1;
		if (x2 > p2.x) p2.x = x2;
		if (y2 > p2.y) p2.y = y2;
		p0.y = y2;
		if (this.next == null || this.isBlockEnd) return this;
		return this.next.calcSize(p0, p1, p2);
	}
	paint(position) {
		var size = FlowchartSetting.size;
		if (position != null) {
			this.x1 = position.x - this.width / 2;
			this.x2 = position.x + this.width / 2;
			this.y1 = position.y;
			this.y2 = this.y1 + this.height;
		}
		flowchart.context.beginPath();
		flowchart.context.moveTo(this.x1, this.y1);
		flowchart.context.lineTo(this.x2, this.y1);
		flowchart.context.lineTo(this.x2, this.y2);
		flowchart.context.lineTo(this.x1, this.y2);
		flowchart.context.lineTo(this.x1, this.y1);
		flowchart.context.stroke();
		flowchart.context.fillText(this.text, this.x1 + size * 2, this.y2 - size);

		if (position != null) {
			position.y = this.y2;
			if (this.end.next != null) return this.end.next.paint(position);
			return this.end;
		}
		return this;
	}
	static appendMe(bar) {
		var parts = new Parts_Substitute();
		bar.next = parts;
		parts.next = new Parts_Bar();
		return parts.next;
	}
	appendCode(code, indent) {
		code += Parts.makeIndent(indent);
		code += this.var + (this.operator ? this.operator : "") + "=" + this.val + "\n";
		if (this.next != null) return this.next.appendCode(code, indent);
		return code;
	}
	editMe() {
		var subtitle = ["変数", "値", "演算"];
		var values = [this.var, this.val, this.operator];
		openModalWindowforSubstitute("代入の編集", subtitle, values, this);
	}
	edited(values) {
		if (values != null) {
			if (values[2] == "（なし）") values[2] = null;
			this.setValue(values[0], values[1], values[2]);
		}
		flowchart.paint();
		flowchart.flowchart2code();
	}
}

class Parts_Append extends Parts {
	constructor() {
		super();
		this.setValue("《変数》", "《値》");
	}
	setValue(variable, value) {
		this._var = variable;
		this._val = value;

		this._text = this._var + "に" + this._val + "を追加";
	}
	get var() { return this._var; }
	get val() { return this._val; }
	calcSize(p0, p1, p2) {
		this.calcTextsize();    // textWidth, textHeightの計算
		var size = FlowchartSetting.size;
		this._height = this._textheight + size * 2;
		this._width = this._textwidth + size * 4;
		var x1 = p0.x - this.width / 2;
		var x2 = p0.x + this.width / 2;
		var y2 = p0.y + this.height;
		if (x1 < p1.x) p1.x = x1;
		if (x2 > p2.x) p2.x = x2;
		if (y2 > p2.y) p2.y = y2;
		p0.y = y2;
		if (this.next == null || this.isBlockEnd) return this;
		return this.next.calcSize(p0, p1, p2);
	}
	paint(position) {
		var size = FlowchartSetting.size;
		if (position != null) {
			this.x1 = position.x - this.width / 2;
			this.x2 = position.x + this.width / 2;
			this.y1 = position.y;
			this.y2 = this.y1 + this.height;
		}
		flowchart.context.beginPath();
		flowchart.context.moveTo(this.x1, this.y1);
		flowchart.context.lineTo(this.x2, this.y1);
		flowchart.context.lineTo(this.x2, this.y2);
		flowchart.context.lineTo(this.x1, this.y2);
		flowchart.context.lineTo(this.x1, this.y1);
		flowchart.context.stroke();
		flowchart.context.fillText(this.text, this.x1 + size * 2, this.y2 - size);

		if (position != null) {
			position.y = this.y2;
			if (this.end.next != null) return this.end.next.paint(position);
			return this.end;
		}
		return this;
	}
	static appendMe(bar) {
		var parts = new Parts_Append();
		bar.next = parts;
		parts.next = new Parts_Bar();
		return parts.next;
	}
	appendCode(code, indent) {
		code += Parts.makeIndent(indent);
		code += this.var + "に" + this.val + "を追加する\n";
		if (this.next != null) return this.next.appendCode(code, indent);
		return code;
	}
	editMe() {
		var subtitle = ["変数", "値"];
		var values = [this.var, this.val];
		openModalWindow("追加の編集", subtitle, values, this);
	}
	edited(values) {
		if (values != null) {
			this.setValue(values[0], values[1]);
		}
		flowchart.paint();
		flowchart.flowchart2code();
	}
}

class Parts_Extend extends Parts {
	constructor() {
		super();
		this.setValue("《変数》", "《値》");
	}
	setValue(variable, value) {
		this._var = variable;
		this._val = value;

		this._text = this._var + "に" + this._val + "を連結";
	}
	get var() { return this._var; }
	get val() { return this._val; }
	calcSize(p0, p1, p2) {
		this.calcTextsize();    // textWidth, textHeightの計算
		var size = FlowchartSetting.size;
		this._height = this._textheight + size * 2;
		this._width = this._textwidth + size * 4;
		var x1 = p0.x - this.width / 2;
		var x2 = p0.x + this.width / 2;
		var y2 = p0.y + this.height;
		if (x1 < p1.x) p1.x = x1;
		if (x2 > p2.x) p2.x = x2;
		if (y2 > p2.y) p2.y = y2;
		p0.y = y2;
		if (this.next == null || this.isBlockEnd) return this;
		return this.next.calcSize(p0, p1, p2);
	}
	paint(position) {
		var size = FlowchartSetting.size;
		if (position != null) {
			this.x1 = position.x - this.width / 2;
			this.x2 = position.x + this.width / 2;
			this.y1 = position.y;
			this.y2 = this.y1 + this.height;
		}
		flowchart.context.beginPath();
		flowchart.context.moveTo(this.x1, this.y1);
		flowchart.context.lineTo(this.x2, this.y1);
		flowchart.context.lineTo(this.x2, this.y2);
		flowchart.context.lineTo(this.x1, this.y2);
		flowchart.context.lineTo(this.x1, this.y1);
		flowchart.context.stroke();
		flowchart.context.fillText(this.text, this.x1 + size * 2, this.y2 - size);

		if (position != null) {
			position.y = this.y2;
			if (this.end.next != null) return this.end.next.paint(position);
			return this.end;
		}
		return this;
	}
	static appendMe(bar) {
		var parts = new Parts_Append();
		bar.next = parts;
		parts.next = new Parts_Bar();
		return parts.next;
	}
	appendCode(code, indent) {
		code += Parts.makeIndent(indent);
		code += this.var + "に" + this.val + "を連結する\n";
		if (this.next != null) return this.next.appendCode(code, indent);
		return code;
	}
	editMe() {
		var subtitle = ["変数", "値"];
		var values = [this.var, this.val];
		openModalWindow("追加の編集", subtitle, values, this);
	}
	edited(values) {
		if (values != null) {
			this.setValue(values[0], values[1]);
		}
		flowchart.paint();
		flowchart.flowchart2code();
	}
}

class Parts_If extends Parts {
	constructor() {
		super();
		this.setValue("《条件》");
		this.left = this.right = null;
		this.left_bar_expand = this.right_bar_expand = 0;
	}
	setValue(cond) {
		this._cond = cond;
		this._text = this._cond;
	}
	get condition() { return this._cond; }
	get end() { return this.next; }

	calcTextsize() {
		if (this.text != null && this.text != "") {
			var size = FlowchartSetting.size;
			var metrics = flowchart.context.measureText(this.text);
			this._hspace = 0;
			this._textwidth = metrics.width;
			if (this._textwidth < size * 6) {
				this._hspace = (size * 6 - this._textwidth) / 2;
				this._textwidth = size * 6;
			}
			this._textheight = FlowchartSetting.fontsize;
		}
	}

	calcSize(p0, p1, p2) {
		this.calcTextsize();    // textWidth, textHeightの計算
		var size = FlowchartSetting.size;
		//		if(this._textwidth < size * 6) this._textwidth = size * 6;
		//		if(this._textheight < size * 2) this._textheight = size * 2;
		this.v_margin = size * 2;
		this.h_margin = this.textWidth * this.textHeight / this.v_margin / 4;
		this._height = this.textHeight + this.v_margin * 2;
		this._width = this.textWidth + this.h_margin * 2;
		var x1 = p0.x - this.width / 2;
		var x2 = p0.x + this.width / 2;
		// 左枝
		var pl = new point(); pl.x = x1; pl.y = p0.y;
		var pl1 = pl.clone(), pl2 = pl.clone();
		this.left.calcSize(pl, pl1, pl2);
		this.left_bar_expand = (pl2.x - pl.x); // - this.width / 2;
		if (this.left_bar_expand < size) this.left_bar_expand = size;
		pl1.x -= this.left_bar_expand;
		pl2.x -= this.left_bar_expand;
		if (pl1.x < p1.x) p1.x = pl1.x;
		if (pl1.y > p1.y) p1.y = pl1.y;
		if (pl2.y > p1.y) p1.y = pl2.y;

		// 右枝
		var pr = new point(); pr.x = x2; pr.y = p0.y;
		var pr1 = pr.clone(), pr2 = pr.clone();
		this.right.calcSize(pr, pr1, pr2);
		this.right_bar_expand = (pr.x - pr1.x); // - this.width / 2;
		if (this.right_bar_expand < size) this.right_bar_expand = size;
		pr1.x += this.right_bar_expand;
		pr2.x += this.right_bar_expand;
		if (pr2.x > p2.x) p2.x = pr2.x;
		if (pr1.y > p2.y) p2.y = pr1.y;
		if (pr2.y > p2.y) p2.y = pr2.y;
		// 左枝と右枝がぶつかっていたら，右枝をちょっと伸ばす
		if (pr1.x < pl2.x + size) {
			this.right_bar_expand += pl2.x - pr1.x + size;
			p2.x += pl2.x - pr1.x + size;
		}
		return this.end.next.calcSize(p0, p1, p2);
	}
	paint(position) {
		var size = FlowchartSetting.size;
		if (position != null) {
			this.x1 = position.x - this.width / 2;
			this.x2 = position.x + this.width / 2;
			this.y1 = position.y;
			this.y2 = this.y1 + this.height;
		}
		var x0 = (this.x1 + this.x2) / 2, y0 = (this.y1 + this.y2) / 2;
		flowchart.context.beginPath();
		flowchart.context.moveTo(x0, this.y1);
		flowchart.context.lineTo(this.x1, y0);
		flowchart.context.lineTo(x0, this.y2);
		flowchart.context.lineTo(this.x2, y0);
		flowchart.context.lineTo(x0, this.y1);
		flowchart.context.stroke();
		flowchart.context.fillText(this.text, x0 - this.textWidth / 2 + this.hspace,
			y0 + this.textHeight / 2);

		if (position != null) {
			// 左側
			flowchart.context.beginPath();
			flowchart.context.moveTo(this.x1, y0);
			flowchart.context.lineTo(this.x1 - this.left_bar_expand, y0);
			flowchart.context.stroke();
			flowchart.context.fillText('Y', this.x1 - size * 1, y0 - size);
			var left_parts = this.left.paint({ x: this.x1 - this.left_bar_expand, y: y0 }).prev;
			// 右側
			flowchart.context.beginPath();
			flowchart.context.moveTo(this.x2, y0);
			flowchart.context.lineTo(this.x2 + this.right_bar_expand, y0);
			flowchart.context.stroke();
			flowchart.context.fillText('N', this.x2 + size * 0, y0 - size);
			var right_parts = this.right.paint({ x: this.x2 + this.right_bar_expand, y: y0 }).prev;
			// 線の下の部分
			var y;
			if (left_parts.y2 > right_parts.y2) {
				y = left_parts.y2;
				flowchart.context.beginPath();
				flowchart.context.moveTo(this.x2 + this.right_bar_expand, right_parts.y2);
				flowchart.context.lineTo(this.x2 + this.right_bar_expand, y);
				flowchart.context.stroke();
				right_parts.y2 = y;
			}
			else {
				y = right_parts.y2;
				flowchart.context.beginPath();
				flowchart.context.moveTo(this.x1 - this.left_bar_expand, left_parts.y2);
				flowchart.context.lineTo(this.x1 - this.left_bar_expand, y);
				flowchart.context.stroke();
				left_parts.y2 = y;
			}
			flowchart.context.beginPath();
			flowchart.context.moveTo(this.x1 - this.left_bar_expand, y);
			flowchart.context.lineTo(this.x2 + this.right_bar_expand, y);
			flowchart.context.stroke();
			position.y = y;
			if (this.end.next != null) return this.end.next.paint(position);
			//			return this.end;
		}
		return this.end.next;
	}
	static appendMe(bar) {
		var parts = new Parts_If();
		bar.next = parts;
		parts.next = new Parts_Null();
		parts.next.next = new Parts_Bar();
		parts.left = new Parts_Bar();
		parts.left._prev = parts;
		parts.left.next = new Parts_Null();
		parts.right = new Parts_Bar();
		parts.right._prev = parts;
		parts.right.next = new Parts_Null();

		return parts.end.next.next;
	}
	appendCode(code, indent) {
		code += Parts.makeIndent(indent);
		code += "もし" + this.condition + "ならば：\n";
		if (this.left.next instanceof Parts_Null) code += Parts.makeIndent(indent + 1) + "\n";
		else code += this.left.appendCode('', indent + 1);
		if (!(this.right.next instanceof Parts_Null)) {
			code += Parts.makeIndent(indent) + "そうでなければ：\n"
			code += this.right.appendCode('', indent + 1);
		}

		if (this.end.next != null) return this.end.next.appendCode(code, indent);
		return code;
	}
	editMe() {
		var subtitle = ["条件"];
		var values = [this.condition];
		openModalWindow("分岐の編集", subtitle, values, this);
	}
	edited(values) {
		if (values != null) {
			this.setValue(values[0]);
		}
		flowchart.paint();
		flowchart.flowchart2code();
	}
}

class Parts_LoopBegin extends Parts {
	get hasText() { return false; }
	get end() { return this._end; }
	calcTextsize() {
		if (this.hasText) {
			var size = FlowchartSetting.size;
			this._textwidth = size * 6;
			this._hspace = this._hspace2 = 0;
			var tw = flowchart.context.measureText(this.text).width;
			if (tw > this._textwidth) this._textwidth = tw;
			if (tw < this._textwidth) this._hspace = (this._textwidth - tw) / 2;
			if (this.text2) {
				var tw2 = flowchart.context.measureText(this.text2).width;
				if (tw2 > this._textwidth) this._textwidth = tw2;
				if (tw < this._textwidth) this._hspace = (this._textwidth - tw) / 2;
				if (tw2 < this._textwidth) this._hspace2 = (this._textwidth - tw2) / 2;
			}
			this._textheight = FlowchartSetting.fontsize;
		}
		else {
			this.end.calcTextsize();
			this._textwidth = this.end.textWidth;
			this._textheight = this.end.textHeight;
		}
	}
	calcSize(p0, p1, p2) {
		this.calcTextsize();    // textWidth, textHeightの計算
		var size = FlowchartSetting.size;

		this._height = this.textHeight * (this.hasText && this.text2 ? 2 : 1) + size * 2;
		this._width = this.textWidth + size * 2;
		var x1 = p0.x - this.width / 2;
		var x2 = p0.x + this.width / 2;
		var y2 = p0.y + this.height;
		if (x1 < p1.x) p1.x = x1;
		if (x2 > p2.x) p2.x = x2;
		if (y2 > p2.y) p2.y = y2;
		p0.y = y2;
		var n = this.next;
		while (n != this.end) n = n.calcSize(p0, p1, p2);
		//		this.next.calcSize(p0,p1,p2);
		return this.end.next.calcSize(p0, p1, p2);
	}
	paint(position) {
		var size = FlowchartSetting.size;
		if (position != null) {
			this.x1 = position.x - this.width / 2;
			this.x2 = position.x + this.width / 2;
			this.y1 = position.y;
			this.y2 = this.y1 + this.height;
		}
		flowchart.context.beginPath();
		flowchart.context.moveTo(this.x1 + size, this.y1);
		flowchart.context.lineTo(this.x2 - size, this.y1);
		flowchart.context.lineTo(this.x2, this.y1 + size);
		flowchart.context.lineTo(this.x2, this.y2);
		flowchart.context.lineTo(this.x1, this.y2);
		flowchart.context.lineTo(this.x1, this.y1 + size);
		flowchart.context.lineTo(this.x1 + size, this.y1);
		flowchart.context.stroke();
		if (this.hasText) {
			flowchart.context.fillText(this.text, this.x1 + size + this.hspace, this.y1 + size + this.textHeight);
			if (this.text2)
				flowchart.context.fillText(this.text2, this.x1 + size + this.hspace2, this.y1 + size + this.textHeight * 2);
		}

		if (position != null) {
			position.y = this.y2;
			this.next.paint(position);
			return this.end.next.paint(position);;
		}
		return this;
	}
	deleteMe() {
		this.prev._next = this.end.next.next;
		this.end.next.next._prev = this.prev;
		this.end._next = null;
		this._next = null;
	}
	highlight() {
		this.paint_highlight();
		this.end.paint_highlight();
	}
	unhighlight() {
		this.paint_unhighlight();
		this.end.paint_unhighlight();
	}


}

class Parts_LoopBegin1 extends Parts_LoopBegin {
	get hasText() { return true; }
	constructor() {
		super();
		this.setValue("《条件》");
	}
	setValue(cond) {
		this._cond = cond;
		this._text = this._cond;
	}
	get condition() { return this._cond; }
	get text2() { return "の間"; }

	static appendMe(bar) {
		var parts = new Parts_LoopBegin1();
		bar.next = parts;
		parts.next = new Parts_Bar();
		parts.next.next = new Parts_LoopEnd();
		parts.next.next.next = new Parts_Bar();
		parts._end = parts.next.next;
		parts.next.next._begin = parts;

		return parts.end;
	}

	appendCode(code, indent) {
		code += Parts.makeIndent(indent);
		code += this.condition + "の間：\n";
		var code_inner = this.next.appendCode('', indent + 1);
		if (code_inner == '') code += Parts.makeIndent(indent + 1) + "\n";
		else code += code_inner;

		if (this.end.next != null) return this.end.next.appendCode(code, indent);
		return code;
	}

	editMe() {
		var subtitle = ["条件（〜の間）"];
		var values = [this.condition];
		openModalWindow("繰り返しの編集", subtitle, values, this);
	}
	edited(values) {
		if (values != null) {
			this.setValue(values[0]);
		}
		flowchart.paint();
		flowchart.flowchart2code();
	}
}

class Parts_LoopBeginFor extends Parts_LoopBegin {
	get hasText() { return true; }
	constructor() {
		super();
		this.setValue("《配列》", "《変数》");
	}
	setValue(array, variable) {
		this.array = array;
		this.variable = variable;
		this._text = this.variable + ':' + this.array;
	}
	get text2() { return null; }
	static appendMe(bar) {
		var parts = new Parts_LoopBeginFor();
		bar.next = parts;
		parts.next = new Parts_Bar();
		parts.next.next = new Parts_LoopEnd();
		parts.next.next.next = new Parts_Bar();
		parts._end = parts.next.next;
		parts.next.next._begin = parts;

		return parts.end;
	}

	appendCode(code, indent) {
		code += Parts.makeIndent(indent);
		code += this.array + "の要素" + this.variable + "について繰り返す：\n";
		var code_inner = this.next.appendCode('', indent + 1);
		if (code_inner == '') code += Parts.makeIndent(indent + 1) + "\n";
		else code += code_inner;

		if (this.end.next != null) return this.end.next.appendCode(code, indent);
		return code;
	}

	editMe() {
		var subtitle = ["配列", "変数"];
		var values = [this.array, this.variable];
		openModalWindow("繰り返しの編集", subtitle, values, this);
	}
	edited(values) {
		if (values != null) {
			this.setValue(values[0], values[1]);
		}
		flowchart.paint();
		flowchart.flowchart2code();
	}
}


class Parts_LoopBeginInc extends Parts_LoopBegin {
	get hasText() { return true; }
	constructor() {
		super();
		this.setValue("《変数》", "《値》", "《値》", "《値》");
	}
	setValue(variable, start, goal, step) {
		this._var = variable;
		this._start = start;
		this._goal = goal;
		this._step = step;
		this._text = this.var + ':' + this.start + "→" + this.goal;
	}
	get var() { return this._var; }
	get start() { return this._start; }
	get goal() { return this._goal; }
	get step() { return this._step; }
	get text2() { return this.step + "ずつ増"; }

	static appendMe(bar) {
		var parts = new Parts_LoopBeginInc();
		bar.next = parts;
		parts.next = new Parts_Bar();
		parts.next.next = new Parts_LoopEnd();
		parts.next.next.next = new Parts_Bar();
		parts._end = parts.next.next;
		parts.next.next._begin = parts;

		return parts.end;
	}

	appendCode(code, indent) {
		code += Parts.makeIndent(indent);
		code += this.var + "を" + this.start + "から" + this.goal + "まで" + this.step + "ずつ増やしながら：\n";
		var code_inner = this.next.appendCode('', indent + 1);
		if (code_inner == '') code += Parts.makeIndent(indent + 1) + "\n";
		else code += code_inner;

		if (this.end.next != null) return this.end.next.appendCode(code, indent);
		return code;
	}

	editMe() {
		var subtitle = ["変数", "〜から", "〜まで", "増加分"];
		var values = [this.var, this.start, this.goal, this.step];
		openModalWindow("繰り返しの編集", subtitle, values, this);
	}
	edited(values) {
		if (values != null) {
			this.setValue(values[0], values[1], values[2], values[3]);
		}
		flowchart.paint();
		flowchart.flowchart2code();
	}
}

class Parts_LoopBeginDec extends Parts_LoopBegin {
	get hasText() { return true; }
	constructor() {
		super();
		this.setValue("《変数》", "《値》", "《値》", "《値》");
	}
	setValue(variable, start, goal, step) {
		this._var = variable;
		this._start = start;
		this._goal = goal;
		this._step = step;
		this._text = this.var + ':' + this.start + "→" + this.goal;
	}
	get var() { return this._var; }
	get start() { return this._start; }
	get goal() { return this._goal; }
	get step() { return this._step; }
	get text2() { return this.step + "ずつ減"; }

	static appendMe(bar) {
		var parts = new Parts_LoopBeginDec();
		bar.next = parts;
		parts.next = new Parts_Bar();
		parts.next.next = new Parts_LoopEnd();
		parts.next.next.next = new Parts_Bar();
		parts._end = parts.next.next;
		parts.next.next._begin = parts;

		return parts.end;
	}

	appendCode(code, indent) {
		code += Parts.makeIndent(indent);
		code += this.var + "を" + this.start + "から" + this.goal + "まで" + this.step + "ずつ減らしながら：\n";
		var code_inner = this.next.appendCode('', indent + 1);
		if (code_inner == '') code += Parts.makeIndent(indent + 1) + "\n";
		else code += code_inner;

		if (this.end.next != null) return this.end.next.appendCode(code, indent);
		return code;
	}

	editMe() {
		var subtitle = ["変数", "〜から", "〜まで", "減少分"];
		var values = [this.var, this.start, this.goal, this.step];
		openModalWindow("繰り返しの編集", subtitle, values, this);
	}
	edited(values) {
		if (values != null) {
			this.setValue(values[0], values[1], values[2], values[3]);
		}
		flowchart.paint();
		flowchart.flowchart2code();
	}
}


class Parts_LoopEnd extends Parts {
	get hasText() { return false; }
	get begin() { return this._begin; }
	get isBlockEnd() { return true; }
	editMe() {
		this.begin.editMe();
	}
	calcTextsize() {
		if (this.hasText) {
			var size = FlowchartSetting.size;
			this._textwidth = size * 6;
			this._hspace = this._hspace2 = 0;
			var tw = flowchart.context.measureText(this.text).width;
			if (tw > this._textwidth) this._textwidth = tw;
			var tw2 = flowchart.context.measureText(this.text2).width;
			if (tw2 > this._textwidth) this._textwidth = tw2;
			if (tw < this._textwidth) this._hspace = (this._textwidth - tw) / 2;
			if (tw2 < this._textwidth) this._hspace2 = (this._textwidth - tw2) / 2;
			this._textheight = FlowchartSetting.fontsize;
			this._textheight = FlowchartSetting.fontsize;
		}
		else {
			this._textwidth = this.begin.textWidth;
			this._textheight = this.begin.textHeight;
		}
	}
	calcSize(p0, p1, p2) {
		this.calcTextsize();    // textWidth, textHeightの計算
		var size = FlowchartSetting.size;

		this._height = this.textHeight * (this.hasText ? 2 : 1) + size * 2;
		this._width = this.textWidth + size * 2;
		var x1 = p0.x - this.width / 2;
		var x2 = p0.x + this.width / 2;
		var y2 = p0.y + this.height;
		if (x1 < p1.x) p1.x = x1;
		if (x2 > p2.x) p2.x = x2;
		if (y2 > p2.y) p2.y = y2;
		p0.y = y2;
		return this; // isBlockEnd is true.
	}
	paint(position) {
		var size = FlowchartSetting.size;
		if (position != null) {
			this.x1 = position.x - this.width / 2;
			this.x2 = position.x + this.width / 2;
			this.y1 = position.y;
			this.y2 = this.y1 + this.height;
		}
		flowchart.context.beginPath();
		flowchart.context.moveTo(this.x1, this.y1);
		flowchart.context.lineTo(this.x2, this.y1);
		flowchart.context.lineTo(this.x2, this.y2 - size);
		flowchart.context.lineTo(this.x2 - size, this.y2);
		flowchart.context.lineTo(this.x1 + size, this.y2);
		flowchart.context.lineTo(this.x1, this.y2 - size);
		flowchart.context.lineTo(this.x1, this.y1);
		flowchart.context.stroke();
		if (this.hasText) {
			flowchart.context.fillText(this.text, this.x1 + size + this.hspace, this.y1 + size + this.textHeight);
			flowchart.context.fillText(this.text2, this.x1 + size + this.hspace2, this.y1 + size + this.textHeight * 2);
		}

		if (position != null) {
			position.y = this.y2;
		}
		return this;
	}
	appendCode(code, indent) {
		return code;
	}
	editMe() {
		//		this.highlight();
		this.begin.editMe();
	}
	deleteMe() {
		this.begin.deleteMe();
	}
	cutMe() {
		this.begin.cutMe();
	}
	highlight() {
		this.paint_highlight();
		this.begin.paint_highlight();
	}
	unhighlight() {
		this.paint_unhighlight();
		this.begin.paint_unhighlight();
	}
}

/**
 *
 * @param {number} l 表示する行数（-1で非表示）
 */
function highlightLine(l) {

}

function reset() {
	varTables = [new varTable()];
	myFuncs = {};
	current_line = -1;
	run_flag = false
	code = null;
	canvas = null
	context = null
	wait_time = 0;
	timeouts = [];
	output_str = ''
}

function run(pypen_source) {
	try {
		reset()
		var dncl_source = python_to_dncl(pypen_source);
		code = [new parsedMainRoutine(dncl.parse(dncl_source))];
	}
	catch (e) {
		reset()
		const texts = []
		if (e.line) texts.push(e.line + "行目");
		texts.push("構文エラーです\n" + e.message + "\n");
		output(texts.join('\n'))
		outputEnd()
		return;
	}
	run_flag = true
	step();
}

// busy wait !!
function wait(ms) {
	let t1 = Date.now();
	while (Date.now() - t1 < ms)
		;
}

var fast_time = 0;

function step() {
	// 次の行まで進める
	var l = current_line;
	do {
		next_line();
	} while (run_flag && l == current_line);
	if (!code) return;
	if (code[0] && code[0].stack.length > 0) {
		if (run_flag && !step_flag) {
			if (wait_time > 0) {
				wait(wait_time);
				wait_time = 0;
			}
			fast_time++
			if (1000 < fast_time) {
				Promise.resolve().then(() => step())
				fast_time = 0
			}
			else {
				step()
			}
		}
	}
	else {
		outputEnd()
		reset()
	}
}

function next_line() {
	var index = code[0].stack[0].index;
	var statement = code[0].stack[0].statementlist[index];
	if (statement) {
		try {
			statement.run();
		}
		catch (e) {
			if (e instanceof RuntimeError) output("\n" + e.line + "行目:" + e.message + "\n");
			else output("実行時エラーです\n" + e + "\n");
			outputEnd()
			reset()
		}
	}
	else code[0].stack[0].index++;
	if (!code || !code[0]) return;
	// 不要になったコードをstackから捨てる
	index = code[0].stack[0] ? code[0].stack[0].index : -1;
	while (index < 0 || index >= code[0].stack[0].statementlist.length) {
		code[0].stack.shift();
		while (code[0] && code[0].stack.length < 1) code.shift();
		if (code.length < 1) break;
		index = (code[0] && code[0].stack[0]) ? code[0].stack[0].index : -1;
	}
	if (selected_quiz < 0) {
		// 次の行をハイライト表示する
		if (code[0] && code[0].stack[0]) {
			index = code[0].stack[0].index;
			statement = code[0].stack[0].statementlist[index];
			if (statement && (statement instanceof Statement)) {
				if (statement.loc) highlightLine(current_line = statement.first_line);
				if (statement instanceof PauseStatement) step_flag = true;
			}
		}
		else highlightLine(++current_line);
	}
}

function registerEvent(elem, ev, func) {
	if (elem.addEventListener) elem.addEventListener(ev, func);
	else if (elem.attachEvent) elem.attachEvent('on' + ev, func);
}

function makePython(code) {
	myFuncs = {};
	python_lib = {};
	try {
		var dncl_code = python_to_dncl(code);
		var main_routine = new parsedMainRoutine(dncl.parse(dncl_code));
		var python_code = main_routine.makePython();
		return python_code;
	}
	catch (e) {
		highlightLine(-1);
		clearOutput();
		if (e.line && e.line > 0) output(e.line + "行目構文エラーです\n");
		output(e.message);
	}
}

function code_dump() {
	let str = '';
	for (let i = 0; i < code.length; i++) {
		str += 'code[' + i + ']\n';
		for (let j = 0; j < code[i].stack.length; j++) {
			let statement = [];
			for (let k = 0; k < code[i].stack[j].statementlist.length; k++)
				if (code[i].stack[j].statementlist[k]) statement.push(constructor_name(code[i].stack[j].statementlist[k]) + '(' + code[i].stack[j].statementlist[k].state + ')');
			str += ' stack[' + j + '][' + code[i].stack[j].index + ']' + statement.join(' ') + '\n';
		}
	}
	console.log(str);
}

/**
 * 出力
 * @param {string} v
 */
function output(v) {
	self.postMessage({
		type: 'output',
		content: v
	})
}

/**
 * 結果表示画面をクリアする
 */
function clearOutput() { }

function outputEnd() {
	if (canvas) {
		canvas.convertToBlob().then(b => {
			self.postMessage({
				type: 'image',
				content: URL.createObjectURL(b)
			})
			self.postMessage({
				type: 'end'
			})
		})
		return
	}
	self.postMessage({
		type: 'end'
	})
}

let inputValue = ''
let isInputOpen = false

function openInputWindow() {
	isInputOpen = true
	run_flag = false
	self.postMessage({
		type: 'inputRequest'
	})
}

function closeInputWindow() {
	isInputOpen = false
	return inputValue
}

self.addEventListener('message', e => {
	const data = e.data

	switch (data.type) {
		case 'run': {
			const code = data.content
			run(code)
			break
		}
		case 'input': {
			if (!isInputOpen) {
				break
			}
			inputValue = data.content
			run_flag = true
			step()
			break
		}
		case 'convert': {
			const code = data.content
			const converted = makePython(code)
			self.postMessage({
				type: 'convert_output',
				content: converted
			})
			break
		}
		default:
			break
	}
})
